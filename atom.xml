<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>泛泛而谈</title>
  <subtitle>大抵浮生若梦，姑且此处销魂。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tomatoyan.github.io/"/>
  <updated>2017-08-31T06:13:31.880Z</updated>
  <id>http://tomatoyan.github.io/</id>
  
  <author>
    <name>Tomato Yan</name>
    <email>632068499@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB学习(一)</title>
    <link href="http://tomatoyan.github.io/2017/08/28/MongoDB%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <id>http://tomatoyan.github.io/2017/08/28/MongoDB学习-一/</id>
    <published>2017-08-28T05:14:52.000Z</published>
    <updated>2017-08-31T06:13:31.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><pre><code>文档是MongoDB中数据的基本单元，类似于关系数据库中的行。
集合可以被看做是没有模式的表。
MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限。
每一个文档都有一个特殊的键 “_id” ，它在文档所处的集合中是唯一的。
</code></pre><h2 id="文档概念"><a href="#文档概念" class="headerlink" title="文档概念"></a>文档概念</h2><ul>
<li>文档中的键 / 值对是有序的，上面的文档和下面的文档是完全不同的；</li>
<li>文档的键是字符串，键不能含有 \0 ，这个字符用来表示键的结尾；</li>
<li>MongoDB不但区分类型，还区分大小写；</li>
<li>MongoDB不允许有重复的键；</li>
<li>集合就是一组文档；</li>
<li>集合是无模式的；</li>
</ul>
<a id="more"></a>
<h2 id="集合概念"><a href="#集合概念" class="headerlink" title="集合概念"></a>集合概念</h2><ul>
<li>集合名不能是空字符串 “”；</li>
<li>集合名不能含有 \0 字符串，这个字符表示集合名的结尾；</li>
<li>集合名不能以“system”开头，这是为系统保留的前缀；</li>
<li>用户创建的集合名字不能含有保留字符 $ ；</li>
</ul>
<h2 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h2><p>MongoDB中多个文档组成集合，同样多个集合组成数据库。一个MongoDB实例可以承载多个数据库，每个数据库拥有0个或多个集合，它们之间可以视为完全独立的。每个数据库有独立的权限控制。<br>数据库名满足的条件：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有空格，. ，$，/，\，\0</li>
<li>应全部小写</li>
<li>最多64字节</li>
</ul>
<p>特殊作用的数据库：</p>
<ul>
<li>dmin：从权限看，这是“root”数据库，一些特定的服务端命令也只能从这个数据库运行。</li>
<li>local：这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config：当Mongo用于分片设置时，cnfig数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>启动MongoDB，由于MongoDB一般作为网络服务器来运行，客户端可以连接到该服务器并执行操作，要启动该服务器，需要运行mongod可执行文件。mongod在没有参数的情况下会使用默认数据目录/data/db，并使用27017端口，如果目录不存在或不可写，服务器会启动失败，如果端口被占用也会启动失败。<br>MongoDB会自带一个JavaScript shell，可以从命令行与MongoDB实例交互。运行mongo启动shell。</p>
<h2 id="Shell的基本操作"><a href="#Shell的基本操作" class="headerlink" title="Shell的基本操作"></a>Shell的基本操作</h2><p>创建、读取、更新、删除(CRUD)。</p>
<h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h3><p>insert函数添加一个文档到集合当中。</p>
<pre><code>post = {
&quot;title&quot;: &quot;My Blog post&quot;,
&quot;content&quot;: &quot;My content&quot;,
&quot;date&quot;: &quot;2014 4 4 14:44:44&quot;
}
</code></pre><p>post对象是一个有效的MongoDB文档，所以可以采用insert保存到blog集合中：<br>db.blog.insert(post)</p>
<h3 id="2-读取"><a href="#2-读取" class="headerlink" title="2. 读取"></a>2. 读取</h3><p>find会返回集合里面的所有文档，若只想查看一个文档，可以选择findOne：<br>db.blog.findOne()<br>使用find时，shell自动显示最多20个匹配文档。<br>db.blog.find()</p>
<h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3. 更新"></a>3. 更新</h3><p>update接受(至少)两个参数：第一个是要更新文档的限定条件，第二个是更新的文档。<br>假设，我们需要在先前的文章增加评论内容，则需要增加一个新的键，<br>post.comments = []<br>然后执行update操作，用新版的文档替换标题为“My Blog post”的文章</p>
<pre><code>db.blog.update({title: &quot;My Blog post&quot;}, post)
{
    &quot;_id&quot; : ObjectId(&quot;59a622650eac87b27720f544&quot;),
    &quot;title&quot; : &quot;My Blog post&quot;,
    &quot;content&quot; : &quot;My content&quot;,
    &quot;date&quot; : &quot;2014 4 4 14:44:44&quot;,
    &quot;comments&quot; : [ ]
}
</code></pre><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h3><p>remove用来从数据库中永久地删除文档，在不使用参数进行调用的情况下，它会删除一个集合内的所有文档。它也可以接受一个文档以指定限定条件。</p>
<pre><code>db.blog.remove({title: &quot;My Blog post&quot;})
</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在shell中，只有db中找不到指定的属性时，才会将其作为集合返回。<br>例如version是数据库函数，</p>
<pre><code>&gt; db.version
function(){
return this.serverBuildInfo.version;
}
</code></pre><p>当有属性值与目标集合同名时，可以使用getCollection函数：</p>
<pre><code>&gt; db.getCollection(&quot;version&quot;);
test.version
db.getCollection(&quot;version&quot;).find() 便会返回集合version中的数据
</code></pre><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><p>MongoDB的文档类似于JSON，在概念上与JavaScript中的对象相似。<br>JSON仅包含6种数据类型，null、布尔、数字、字符串、数组、对象。<br>MongoDB在保留JSON基本键值对的基础上，添加了其他的一些数据类型，</p>
<ul>
<li>null 用来表示空值或者不存在的字段   {“x”: null}</li>
<li>布尔 有两个值 ‘true’ 和 ‘false’   {“x”: true}</li>
<li>32 位整数 shell中这个类型不可用，因为JavaScript仅支持64位浮点数，所以32位整数会被自动转换</li>
<li>64位整数 shell中不支持这个类型，shell会使用一个特殊的内嵌文档来显示64位整数</li>
<li>64位浮点数 shell中的数字都是这个类型</li>
<li>字符串 UTF-8字符串都可以表示为字符串类型的数据</li>
<li>符号 shell不支持这种类型，shell将数据库里的符号类型转换成字符串</li>
<li>对象id 对象id是文档的12字节的唯一ID   {“x”: ObjectId()}</li>
<li>日期 日期类型存数的时从标准纪元开始的毫秒数，不存储时区   {“x”: new Date()}</li>
<li>正则表达式 采用JavaScript的正则表达式的语法   {“x”: /footbar/i}</li>
<li>代码 文档中可以有JavaScript代码   {“x”: function{/<em> … </em>/}}</li>
<li>二进制数据 二进制数据可以由任意字节的串组成，shell中没有这个类型</li>
<li>最大值 BSON包含一个特殊类型，表示可能的最大值，shell中没有这个类型</li>
<li>最小值 BSON包含一个特殊类型，表示可能的最小值，shell中没有这个类型</li>
<li>未定义 文档中也可以用未定义类型(JavaScript中null和undefined是不同的类型)   {“x”: undefined}</li>
<li>数组 值的集合或者列表可以表示成数组   {“x”: [“a”, “b”, “c”]}</li>
<li>内嵌文档 文档可以包含别的文档，也可以作为值嵌入到父文档中   {“x”: {“hello”: “hi”}}</li>
</ul>
<h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于JavaScript中只有一种数字类型，默认情况下shell中的数字都被MongoDB当作是双精度数。这意味着从数据库中获得的是一个32位整数，修改文档后，当文档返回数据库时，这个整数也被转换成了浮点数。<br>在JavaScript中，Date对象用作MongoDB的日期类型，创建一个新的Date对象时，通常调用new Date()，而不只是Date()，调用构造函数实际返回的是对日期的字符串表示，而不是真正的Date对象，如果忘记使用Date构造函数，就会造成日期和字符串的混淆。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MongoDB中存储的文档必须有一个”_id”键。这个键的值可以是任何类型的，默认是个ObjectId对象，在一个集合里，每个文档都有唯一的“_id”值。ObjectId使用12字节的存储空间，每个字节两位十六进制数字，是一个24位的字符串。12字节按照如下方式生成：</p>
<pre><code>0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10 |11
时间戳      | 机器   |PID  | 计数器
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前4个字节是从标准纪元开始的时间戳，单位为秒。由于时间戳在前，这意味着ObjectId会大致按插入顺序排序。<br>接下来3个字节是所在主机的唯一标识符，通常是机器主机名的散列值，保证了不同主机生产不同的ObjectId<br>为了保证同一台机器上并发的多个进程产生的ObjectId是唯一的，之后的2字节来自产生ObjectId的进程标识符(PID)<br>前9字节保证了同一秒钟不同机器不同进程产生的ObjectId是唯一的。后3个字节是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId也是不一样的。<br>同一秒钟最多允许每个进程拥有 256^3（16777216）个不同的ObjectId。</p>
<h3 id="自动生成-id"><a href="#自动生成-id" class="headerlink" title="自动生成_id"></a>自动生成_id</h3><p>如果插入文档的时候并没有 _id 键，系统会自动创建一个，这个操作通常会在客户端由驱动程序完成。</p>
<ul>
<li>虽然ObjectId设计为轻量型，但生成毕竟是还是会产生开销。在客户端生成体现了MongoDB的设计理念，能从服务器端转移到驱动程序来做的事，就尽量转移。将事务交由客户端来处理，就减轻了数据库扩展的负担。</li>
<li><p>在客户端生成ObjectId，驱动程序能够提供更加丰富的API。</p>
<h2 id="使用MongoDBshell"><a href="#使用MongoDBshell" class="headerlink" title="使用MongoDBshell"></a>使用MongoDBshell</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动mongo shell时不连接到任何mongod，可以通过 –nodb 参数启动。启动之后，在需要时运行new Mongo(hostname) 命令就可以连接到想要的mongod了。</p>
<blockquote>
<p>conn = new Mongo(“localhost:27017”)   // 连接本地操作<br>  connection to localhost:27017<br>db = conn.getDB(“test”)   // test 为数据库名<br>  test</p>
</blockquote>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shell内置了帮助文档，可以使用help命令来查看。可以通过 db.help() 查看数据库级别的帮助。</p>
<h3 id="使用shell执行脚本"><a href="#使用shell执行脚本" class="headerlink" title="使用shell执行脚本"></a>使用shell执行脚本</h3><pre><code>$ mongo script1.js script2.js script3.js
mongo shell会依次执行传入的脚本，然后退出。
如果希望指定主机/端口上的mongod运行脚本，需要先指定地址，然后再跟上脚本文件的名称：$ mongo --quiet localhost:27017/test script1.js
这样可以将db指向 localhost:27017上的test数据库，然后运行 script1.js 脚本。
也可以用load()函数，从交互式shell中运行脚本：
&gt; load(&quot;script1.js&quot;)
shell辅助函数对应的JavaScript函数
辅助函数等价函数use 数据库名db.getSisterDB(&quot;数据库名&quot;)show dbsdb.getMongo().getDBs()show collectionsdb.getCollectionNames()
</code></pre><h3 id="创建-mongorc-js-文件"><a href="#创建-mongorc-js-文件" class="headerlink" title="创建 .mongorc.js 文件"></a>创建 .mongorc.js 文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某些脚本会被频繁加载，可以将它们添加到 mongorc.js 文件中。这个文件会在启动shell时自动运行。</p>
<pre><code>例如：我们希望启动成功时让shell显示一句欢迎语，为此我们在用户主目录下创建一个名为
.mongorc.js 的文件，向其中添加如下内容：
// mongorc.js
var compliment = [&quot;atteactive&quot;, &quot;intelligent&quot;, &quot;like Batman&quot;];
var index = Math.floor(Math.random()*3);
print(&quot;Hello, you&apos;re looking particularly &quot;+compliment[index]+&quot; today!&quot;)
然后，当启动shell时，就会看到这样一些内容：
$ mongo
MongoDB shell version v3.4.4
Hello, you&apos;re looking particularly like Batman today！
</code></pre><h3 id="定制shell提示"><a href="#定制shell提示" class="headerlink" title="定制shell提示"></a>定制shell提示</h3><pre><code>在 .mongorc.js 文件中将prompt变量设为一个字符串或者函数，就可以重写默认的shell提示。
显示当前时间：
prompt = function(){
return (new Date())+&quot;&gt;&quot;;
};
提示当前使用的数据库：
prompt = function(){
if(typeof db == &apos;undefined&apos;){
return &apos;(nodb)&gt;&apos;;
}
// 检查最后的数据库操作
try{
db.runCommand({getLastError:1});
}catch(e){
print(e);
}
return db+&quot;&gt;&quot;;
};
</code></pre><p>&lt;!- end -&gt;</p>
<p><br><br><br><br><br><br><br><br><br><br><br>读书笔记 — MongoDB权威指南 转载表明出处 TomatoYan<br><!--戎戎 我喜欢你--></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;文档是MongoDB中数据的基本单元，类似于关系数据库中的行。
集合可以被看做是没有模式的表。
MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限。
每一个文档都有一个特殊的键 “_id” ，它在文档所处的集合中是唯一的。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;文档概念&quot;&gt;&lt;a href=&quot;#文档概念&quot; class=&quot;headerlink&quot; title=&quot;文档概念&quot;&gt;&lt;/a&gt;文档概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文档中的键 / 值对是有序的，上面的文档和下面的文档是完全不同的；&lt;/li&gt;
&lt;li&gt;文档的键是字符串，键不能含有 \0 ，这个字符用来表示键的结尾；&lt;/li&gt;
&lt;li&gt;MongoDB不但区分类型，还区分大小写；&lt;/li&gt;
&lt;li&gt;MongoDB不允许有重复的键；&lt;/li&gt;
&lt;li&gt;集合就是一组文档；&lt;/li&gt;
&lt;li&gt;集合是无模式的；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mongoDB" scheme="http://tomatoyan.github.io/tags/mongoDB/"/>
    
      <category term="读书笔记" scheme="http://tomatoyan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的安装</title>
    <link href="http://tomatoyan.github.io/2017/08/23/MongoDB%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://tomatoyan.github.io/2017/08/23/MongoDB的安装/</id>
    <published>2017-08-23T11:40:57.000Z</published>
    <updated>2017-08-31T06:10:53.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mongodb-Linux下的安装"><a href="#mongodb-Linux下的安装" class="headerlink" title="mongodb Linux下的安装"></a>mongodb Linux下的安装</h1><h2 id="下载mongodb"><a href="#下载mongodb" class="headerlink" title="下载mongodb"></a>下载mongodb</h2><pre><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.4.7.tgz
</code></pre><h2 id="解压mongodb安装包"><a href="#解压mongodb安装包" class="headerlink" title="解压mongodb安装包"></a>解压mongodb安装包</h2><pre><code>tar -zxvf mongodb-linux-x86_64-amazon-3.4.7.tgz
</code></pre><h2 id="将解压后的文件移动到指定目录-可选"><a href="#将解压后的文件移动到指定目录-可选" class="headerlink" title="将解压后的文件移动到指定目录(可选)"></a>将解压后的文件移动到指定目录(可选)</h2><pre><code>mv mongodb-linux-x86_64-amazon-3.4.7/  /usr/local/mongodb
</code></pre><a id="more"></a>
<h2 id="配置环境变量："><a href="#配置环境变量：" class="headerlink" title="配置环境变量："></a>配置环境变量：</h2><pre><code>vim ~/.bashrc  添加如下内容：
export MONGODB_HOME=/usr/local/mongodb
export PATH=$MONGODB_HOME/bin:$PATH

配置生效： source ~/.bashrc
mongod -v 查看mongodb版本信息查看环境变量是否配置正确
</code></pre><h2 id="创建数据库目录："><a href="#创建数据库目录：" class="headerlink" title="创建数据库目录："></a>创建数据库目录：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录,注意：如果你的数据库目录不是/data/db，可以通过 –dbpath 来指定<br>mkdir -p /data/db<br>mkdir -p /data/log<br>touch /data/log/mongodb.log</p>
<h3 id="添加配置文件："><a href="#添加配置文件：" class="headerlink" title="添加配置文件："></a>添加配置文件：</h3><pre><code>touch /etc/conf/mongodb.conf
新建mongodb.conf配置文件
vim /etc/conf/mongodb.conf
</code></pre><h3 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h3><pre><code>dbpath=/data/db
logpath=/data/log/mongodb.log
logappend=true
port=27017
&lt;!-- 配置放在其他位置没有试过 --&gt;
</code></pre><h3 id="配置文件参数说明"><a href="#配置文件参数说明" class="headerlink" title="配置文件参数说明:"></a>配置文件参数说明:</h3><h4 id="mongodb的参数说明："><a href="#mongodb的参数说明：" class="headerlink" title="mongodb的参数说明："></a>mongodb的参数说明：</h4><pre><code>--dbpath 数据库路径(数据文件)
--logpath 日志文件路径
--master 指定为主机器
--slave 指定为从机器
--source 指定主机器的IP地址
--pologSize 指定日志文件大小不超过64M.因为resync是非常操作量大且耗时，最好通过设置一个足够大的oplogSize来避免resync(默认的 oplog大小是空闲磁盘大小的5%)。
--logappend 日志文件末尾添加
--port 启用端口号
--fork 在后台运行
--only 指定只复制哪一个数据库
--slavedelay 指从复制检测的时间间隔
--auth 是否需要验证权限登录(用户名和密码)
</code></pre><h2 id="通过配置文件启动服务："><a href="#通过配置文件启动服务：" class="headerlink" title="通过配置文件启动服务："></a>通过配置文件启动服务：</h2><pre><code>mongod --journal -f /etc/mongodb.conf  --fork (32位系统需要加参数 --journal  fork后台运行服务) 
</code></pre><h2 id="通过配置文件关闭服务："><a href="#通过配置文件关闭服务：" class="headerlink" title="通过配置文件关闭服务："></a>通过配置文件关闭服务：</h2><pre><code>mongod --journal --shutdown -f /etc/mongodb.conf
可以省略为 mongod --shutdown
</code></pre><h2 id="通过命令行启动服务："><a href="#通过命令行启动服务：" class="headerlink" title="通过命令行启动服务："></a>通过命令行启动服务：</h2><pre><code>mongod --dbpath=/data/db/ --logpath=/data/log/mongodb.log --fork
</code></pre><h2 id="进入mongodb后台管理shell"><a href="#进入mongodb后台管理shell" class="headerlink" title="进入mongodb后台管理shell"></a>进入mongodb后台管理shell</h2><pre><code>进入bin目录 cd /usr/local/mongodb/bin
执行   ./mongo
</code></pre><h3 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h3><pre><code>命令： use test
switched to db test
</code></pre><h3 id="创建用户，设置权限"><a href="#创建用户，设置权限" class="headerlink" title="创建用户，设置权限"></a>创建用户，设置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">user:&quot;test&quot;,&lt;br&gt;</div><div class="line">pwd:&quot;test&quot;, &lt;br&gt;</div><div class="line">roles:[&#123;role:&quot;readWrite&quot;, db:&quot;test&quot;&#125;]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170827185436097?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="mongodb-web界面"><a href="#mongodb-web界面" class="headerlink" title="mongodb web界面"></a>mongodb web界面</h2><pre><code>mongod -f /etc/mongodb.conf --rest
在地址栏输入 127.0.0.1:28017     注意，端口号会比默认设定增加100
</code></pre><h1 id="Window下的安装"><a href="#Window下的安装" class="headerlink" title="Window下的安装"></a>Window下的安装</h1><h2 id="首先下载安装包"><a href="#首先下载安装包" class="headerlink" title="首先下载安装包"></a>首先下载安装包</h2><p><img src="http://img.blog.csdn.net/20170827185532993?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170827185602246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170827185626674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<pre><code>此时已经有了一个db的文件夹
</code></pre><h2 id="在Windows下运行MongoDB服务器"><a href="#在Windows下运行MongoDB服务器" class="headerlink" title="在Windows下运行MongoDB服务器"></a>在Windows下运行MongoDB服务器</h2><pre><code>1. 进入MongoDB下的bin目录
2. 执行mongod.exe 文件
.\mongod.exe --dbpath &quot;C:\Programs\mongodb_sample\data\db&quot;
&quot;C:\Programs\mongodb_sample\data\db&quot; 是数据库的文件目录
3. 执行成功会有如下的输出：
</code></pre><p><img src="http://img.blog.csdn.net/20170827185657764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<pre><code>然后打开新的窗口输入  .\mongo.exe即可进入mongodb服务器
</code></pre><p><img src="http://img.blog.csdn.net/20170827185825745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mongodb-Linux下的安装&quot;&gt;&lt;a href=&quot;#mongodb-Linux下的安装&quot; class=&quot;headerlink&quot; title=&quot;mongodb Linux下的安装&quot;&gt;&lt;/a&gt;mongodb Linux下的安装&lt;/h1&gt;&lt;h2 id=&quot;下载mongodb&quot;&gt;&lt;a href=&quot;#下载mongodb&quot; class=&quot;headerlink&quot; title=&quot;下载mongodb&quot;&gt;&lt;/a&gt;下载mongodb&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.4.7.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;解压mongodb安装包&quot;&gt;&lt;a href=&quot;#解压mongodb安装包&quot; class=&quot;headerlink&quot; title=&quot;解压mongodb安装包&quot;&gt;&lt;/a&gt;解压mongodb安装包&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;tar -zxvf mongodb-linux-x86_64-amazon-3.4.7.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;将解压后的文件移动到指定目录-可选&quot;&gt;&lt;a href=&quot;#将解压后的文件移动到指定目录-可选&quot; class=&quot;headerlink&quot; title=&quot;将解压后的文件移动到指定目录(可选)&quot;&gt;&lt;/a&gt;将解压后的文件移动到指定目录(可选)&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;mv mongodb-linux-x86_64-amazon-3.4.7/  /usr/local/mongodb
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="mongoDB" scheme="http://tomatoyan.github.io/tags/mongoDB/"/>
    
  </entry>
  
  <entry>
    <title>jvisualvm远程监控Tomcat</title>
    <link href="http://tomatoyan.github.io/2017/08/09/jvisualvm%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7Tomcat/"/>
    <id>http://tomatoyan.github.io/2017/08/09/jvisualvm远程监控Tomcat/</id>
    <published>2017-08-09T10:02:17.000Z</published>
    <updated>2017-08-31T06:10:40.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VisualVM(All-in-One Java Trouble Tool)是到目前为止随JDK发布功能最强大的运行监视和故障处理程序。而且VisualVM不需要被监视的程序基于特殊Agent运行，因此它对实际性能的影响很小，使得它可以直接应用在生产环境中。<br>界面如下：<br><img src="http://img.blog.csdn.net/20170809183644088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="界面1"></p>
<a id="more"></a>
<p><img src="http://img.blog.csdn.net/20170809183710495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="界面2"></p>
<h2 id="VisualVM的功能"><a href="#VisualVM的功能" class="headerlink" title="VisualVM的功能"></a>VisualVM的功能</h2><p>VisualVM可以做到：</p>
<ul>
<li>显示虚拟机进程以及进程的配置、环境信息(jsp、jinfo)。</li>
<li>监视应用程序的CPU、GC、堆、方法区以及线程的信息(jstat、jstack)。</li>
<li>dump以及分析堆转储快照(jmap、jhat)。</li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</li>
</ul>
<h2 id="VisualVM安装插件"><a href="#VisualVM安装插件" class="headerlink" title="VisualVM安装插件"></a>VisualVM安装插件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于墙的原因，所以需要采取些措施，才能顺利的下载安装插件。<br><img src="http://img.blog.csdn.net/20170810153927241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="插件"></p>
<h2 id="jvisualvm远程监控Tomcat"><a href="#jvisualvm远程监控Tomcat" class="headerlink" title="jvisualvm远程监控Tomcat"></a>jvisualvm远程监控Tomcat</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入我们的正题，利用jvisualvm远程监控Tomcat服务器。这里的Tomcat部署在远程Linux服务器上。</p>
<h3 id="1-修改Tomcat下bin目录下的startup-sh"><a href="#1-修改Tomcat下bin目录下的startup-sh" class="headerlink" title="1.修改Tomcat下bin目录下的startup.sh"></a>1.修改Tomcat下bin目录下的startup.sh</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在startup.sh倒数第二行，也就是exec “$PRGDIR”/“$EXECUTABLE” start “$@”上一行添加如下内容：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>export CATALINA_OPTS=&quot;$CATALINA_OPTS
-Dcom.sun.management.jmxremote
-Djava.rmi.server.hostname=192.168.1.130
-Dcom.sun.management.jmxremote.port=8888
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=true
-Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password
-Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access&quot;</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;各个参数的说明如下：</p>
<pre><code>-Dcom.sun.management.jmxremote   #启用JMX远程监控
-Djava.rmi.server.hostname=192.168.1.130  #Tomcat服务器地址
-Dcom.sun.management.jmxremote.port=8888  #jmx连接端口
-Dcom.sun.management.jmxremote.ssl=false   #是否ssl加密
-Dcom.sun.management.jmxremote.authenticate=false   #远程连接不需要密码认证
-Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password   #指定连接的用户名和密码配置文件
-Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access   #指定连接的用户所拥有权限的配置文件
</code></pre><h3 id="2-修改服务器上Tomcat的配置："><a href="#2-修改服务器上Tomcat的配置：" class="headerlink" title="2.修改服务器上Tomcat的配置："></a>2.修改服务器上Tomcat的配置：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要修改两个配置文件，首先进入 JAVA_HOME\jre\lib\management 目录下，拷贝和修改jmxremote.password.template为jmxremote.password，操作为：<br>取消最后两行代码的注释，</p>
<pre><code>\# monitorRole  QED   ---&gt;   monitorRole  QED
\# controlRole   R&amp;D   ---&gt;   controlRole   R&amp;D
</code></pre><p>拷贝和修改文件jmxremote.access，操作为：</p>
<pre><code>monitorRole   readonly
controlRole   readwrite
</code></pre><h3 id="3-将文件拷贝至服务器上Tomcat下的conf目录下"><a href="#3-将文件拷贝至服务器上Tomcat下的conf目录下" class="headerlink" title="3.将文件拷贝至服务器上Tomcat下的conf目录下"></a>3.将文件拷贝至服务器上Tomcat下的conf目录下</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即和tomcat的配置文件放在一起</p>
<h3 id="4-修改两个文件权限"><a href="#4-修改两个文件权限" class="headerlink" title="4.修改两个文件权限"></a>4.修改两个文件权限</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改jmxremote.access和jmxremote.password的权限：sudo chmod 600 jmx*</p>
<h3 id="5-重新启动Tomcat"><a href="#5-重新启动Tomcat" class="headerlink" title="5.重新启动Tomcat"></a>5.重新启动Tomcat</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以查看log下的日志看是否有错，并解决。</p>
<h3 id="6-打开jvisualvm"><a href="#6-打开jvisualvm" class="headerlink" title="6.打开jvisualvm"></a>6.打开jvisualvm</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1 添加远程主机 6.2 添加JMX连接 确定连接即可<br><img src="http://img.blog.csdn.net/20170809183806389?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="连接"></p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h2 id="监控JVM中运行的Java程序"><a href="#监控JVM中运行的Java程序" class="headerlink" title="监控JVM中运行的Java程序"></a>监控JVM中运行的Java程序</h2><p>前提：远程机器需要有Java环境</p>
<p>1.在%JAVA_HOME%\bin目录下创建一个文件：jstatd.all.policy（名字可以变，扩展名不可以变），内容如下：</p>
<pre><code>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {
   permission java.security.AllPermission;
};
</code></pre><p>这个文件的作用是让jstatd服务能够读取机器上的java应用程序的运行数据。</p>
<p>2.在%JAVA_HOME%\bin目录下，执行如下命令：</p>
<p>jstatd -J-Djava.security.policy=jstatd.all.policy</p>
<p>3.展开刚所新建的远程主机，就可看到运行在远程机器上的JAVA应用程序了</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstatd.html" title="jstatd - Virtual Machine jstat Daemon" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstatd.html</a></p>
<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VisualVM：多合一故障处理工具&quot;&gt;&lt;a href=&quot;#VisualVM：多合一故障处理工具&quot; class=&quot;headerlink&quot; title=&quot;VisualVM：多合一故障处理工具&quot;&gt;&lt;/a&gt;VisualVM：多合一故障处理工具&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;VisualVM(All-in-One Java Trouble Tool)是到目前为止随JDK发布功能最强大的运行监视和故障处理程序。而且VisualVM不需要被监视的程序基于特殊Agent运行，因此它对实际性能的影响很小，使得它可以直接应用在生产环境中。&lt;br&gt;界面如下：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170809183644088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;界面1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="jvm" scheme="http://tomatoyan.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Docker教程</title>
    <link href="http://tomatoyan.github.io/2017/08/07/Docker%E6%95%99%E7%A8%8B/"/>
    <id>http://tomatoyan.github.io/2017/08/07/Docker教程/</id>
    <published>2017-08-07T07:45:12.000Z</published>
    <updated>2017-08-31T06:10:30.702Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;lt;!- end -&amp;gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>配置最小oracle实例单元</title>
    <link href="http://tomatoyan.github.io/2017/08/07/%E9%85%8D%E7%BD%AE%E6%9C%80%E5%B0%8Foracle%E5%AE%9E%E4%BE%8B%E5%8D%95%E5%85%83/"/>
    <id>http://tomatoyan.github.io/2017/08/07/配置最小oracle实例单元/</id>
    <published>2017-08-07T07:12:56.000Z</published>
    <updated>2017-08-31T06:12:00.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Oracle开发的关系数据库产品因性能卓越而闻名，许多大型网站也选用了Oracle系统，是世界最好的数据库产品。但Oracle数据库管理软件却十分庞大，在本地安装总会开启一堆服务，同时占用大量的磁盘空间和内存。Oracle提供了Oracle SQL Developer这样的管理工具(下载地址: <a href="http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL" target="_blank" rel="external">http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL</a> Developer是Oracle公司出品的一个免费非开源的用以开发数据库应用程序的图形化工具，使用 SQL Developer 可以浏览数据库对象、运行 SQL 语句和脚本、编辑和调试 PL/SQL 语句，但SQL Developer 需要的开发环境要去会比较高(JDK &gt;1.8)，同时，只可以连接到任何Oracle 10g及其后续版本的数据库，此外SQL Developer市场占有率并不高，市场份额基本都被PL/SQL Developer所占有。而PL/SQL Developer 的使用需要有Oracle的一些支持(SQL Developer不需要)，所以我们需要配置最小Oracle实例单元。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h3><pre><code>1.需要在Oracle官网下载简易的oracle数据库客户端(instantclient-basiclite-nt-11.20.0.4.0)，大小仅仅10多M。下载instantclient-basic-win32-11.2.0.1.0
（oracle官网下载地址http://www.oracle.com/technetwork/topics/winsoft-085727.html )
2.下载PL/SQL客户端(官网(https://www.allroundautomations.com/bodyplsqldevreg.html)试用，也可以下载破解版)
</code></pre><h2 id="配置Oracle监听"><a href="#配置Oracle监听" class="headerlink" title="配置Oracle监听"></a>配置Oracle监听</h2><p>解压instantclient-basiclite-nt-11.20.0.4.0 在其文件夹中新建 network 文件夹，新建 admin 文件夹，这个类似oracle数据库的network -&gt; admin，在文件夹中新建 tnsnames.ora 或者从有数据库客户端的地方拷贝。</p>
<pre><code>TEST =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = xxx.xxx.xxx.xxx)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SID = test)
    )
  )
</code></pre><p>也可以直接从oracle客户端里面找到tnsnames.ora文件，直接copy到ADMIN文件下。</p>
<h2 id="设置PL-SQL-Developer"><a href="#设置PL-SQL-Developer" class="headerlink" title="设置PL/SQL Developer"></a>设置PL/SQL Developer</h2><p>打开PLSQL Developer，选择Tools -&gt; perference -&gt; Connection，配置其中的Oracle Home和OCI Library项，如下图所示：</p>
<p><img src="https://ws1.sinaimg.cn/large/be936de3ly1ficcvx09ujj20iv0e5dh4.jpg" alt=""></p>
<pre><code>其中, Oracle Home：E:\app\Administrator\product\instantclient_11_2
     OCI Library：E:\app\Administrator\product\instantclient_11_2\oci.dll
</code></pre><h2 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h2><p>右击”我的电脑” - “属性” - “高级” - “环境变量” - “系统环境变量”:</p>
<pre><code>1&gt;.选择&quot;Path&quot; - 点击&quot;编辑&quot;, 把 &quot;E:\app\Administrator\product\instantclient_11_2;&quot; 加入;
2&gt;.点击&quot;新建&quot;, 变量名设置为&quot;TNS_ADMIN&quot;, 变量值设置为&quot;E:\app\Administrator\product\instantclient_11_2;&quot;, 点击&quot;确定&quot;;
3&gt;.点击&quot;新建&quot;, 变量名设置为&quot;NLS_LANG&quot;, 变量值设置为&quot;SIMPLIFIED CHINESE_CHINA.ZHS16GBK&quot;, 点击&quot;确定&quot;;字符编码变量配置，防止有乱码
</code></pre><p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Oracle开发的关系数据库产品因性能卓越而闻名，许多大型网站也选用了Oracle系统，是世界最好的数据库产品。但Oracle数据库管理软件却十分庞大，在本地安装总会开启一堆服务，同时占用大量的磁盘空间和内存。Oracle提供了Oracle SQL Developer这样的管理工具(下载地址: &lt;a href=&quot;http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL&lt;/a&gt; Developer是Oracle公司出品的一个免费非开源的用以开发数据库应用程序的图形化工具，使用 SQL Developer 可以浏览数据库对象、运行 SQL 语句和脚本、编辑和调试 PL/SQL 语句，但SQL Developer 需要的开发环境要去会比较高(JDK &amp;gt;1.8)，同时，只可以连接到任何Oracle 10g及其后续版本的数据库，此外SQL Developer市场占有率并不高，市场份额基本都被PL/SQL Developer所占有。而PL/SQL Developer 的使用需要有Oracle的一些支持(SQL Developer不需要)，所以我们需要配置最小Oracle实例单元。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://tomatoyan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>澜澜的天上白云飘</title>
    <link href="http://tomatoyan.github.io/2017/08/04/%E6%BE%9C%E6%BE%9C%E7%9A%84%E5%A4%A9%E4%B8%8A%E7%99%BD%E4%BA%91%E9%A3%98/"/>
    <id>http://tomatoyan.github.io/2017/08/04/澜澜的天上白云飘/</id>
    <published>2017-08-04T11:03:44.000Z</published>
    <updated>2017-08-12T15:45:23.666Z</updated>
    
    <content type="html"><![CDATA[<p>悄悄的告诉你这是一个随笔</p>
<pre><code>当神已无能为力，那便是魔渡众生。

你是伤我的剑。
</code></pre><p>&lt;!- end -&gt;</p>
<!-- 
     1
    别傻了，他不会回来的。
    “师兄说他当了最强的剑客便会回来了。”
    “这你也信，就他那修为，怎么会比得过荒嫖客呢~”

    荒嫖客何许人也？
    嫖这一字简练而生动，他剑术了得善攻人心，嫖心之术神佛敬畏。
    荒唐度日，嫖以维生，客以渡人。反而向他说的像个脱世之人，孰不知渡人之术乃是房中秘术，渡人则是以身渡人，以养剑气。

    而这位师兄只先前不过是一个落魄的书生，自以为书可以救人，可以化繁为简，阅己救人，或更是出人头地，娶得娇妻爱妾夜夜笙歌。乱世之中何来盛世之书，自得习武。
    书生好胜，自不愿武学差矣他人，剑以君子自居，自当学剑，立不世之功。
    何妨，剑气难养，故人以气养剑，以淫养气，以水养气，无所不养，无所不及。

    立不世之功，自当剑气浩荡，气煞旁荒。

      2
    “别打了，你剑气未足，我用脚都能。。。”
    “再来~”
    “真是浪费。”
    荒嫖客头也不回，向醉花楼走去。
    “师兄。。。”
    颓败之际唯有美酒与美女才能让人向往，不错，女人总是男人的解药。

    而你是伤我的剑。
-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;悄悄的告诉你这是一个随笔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当神已无能为力，那便是魔渡众生。

你是伤我的剑。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;lt;!- end -&amp;gt;&lt;/p&gt;
&lt;!-- 
     1
    别傻了，他不会回来的。
    “师兄说他当了最强的剑客便
    
    </summary>
    
    
      <category term="随笔" scheme="http://tomatoyan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡的搭建</title>
    <link href="http://tomatoyan.github.io/2017/08/02/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://tomatoyan.github.io/2017/08/02/Nginx负载均衡的搭建/</id>
    <published>2017-08-02T02:56:18.000Z</published>
    <updated>2017-08-31T06:11:29.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx的简介"><a href="#Nginx的简介" class="headerlink" title="Nginx的简介"></a>Nginx的简介</h2><p>Nginx 是一个很强大的高性能Web和反向代理服务器。</p>
<h2 id="Nginx优点"><a href="#Nginx优点" class="headerlink" title="Nginx优点"></a>Nginx优点</h2><ol>
<li>作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率。在高连接并发的情况下，Nginx是Apache服务器不错的替代品，能够支持高达 50000 个并发连接数的响应。</li>
<li>Nginx 配置简洁, Apache 复杂 ，Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 . Nginx 静态处理性能比 Apache 高 3倍以上 ，Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端来使用 ,Apache 的组件比 Nginx 多. </li>
<li>最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；Nginx是异步的，多个连接（万级别）可以对应一个进程 .</li>
<li>Nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用Nginx作为反向代理抗住压力，apache作为后端处理动态请求。</li>
</ol>
<a id="more"></a>
<h2 id="Nginx-工作原理"><a href="#Nginx-工作原理" class="headerlink" title="Nginx 工作原理"></a>Nginx 工作原理</h2><p>Nginx会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。主进程以root用户身份运行，而worker、 cache loader和cache manager均应以非特权用户身份运行。</p>
<h2 id="Nginx的使用"><a href="#Nginx的使用" class="headerlink" title="Nginx的使用"></a>Nginx的使用</h2><p>目标：利用Nginx服务器反向代理对Tomcat进行负载均衡<br>需要的工具：Nginx、Tomcat<br>负载均衡：</p>
<h3 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><ol>
<li>首先下载 Nginx (<a href="http://nginx.org/en/download.html)在Linux上解压" target="_blank" rel="external">http://nginx.org/en/download.html)在Linux上解压</a> tar zxvf nginx-0.x.xx.tar.gz<br>进入解压目录：cd nginx-0.x.xx<br>./configure<br>make<br>sudo make install</li>
<li>Windows只需要解压即可完成安装</li>
</ol>
<h3 id="Nginx的启动"><a href="#Nginx的启动" class="headerlink" title="Nginx的启动"></a>Nginx的启动</h3><p>以上安装 nginx默认解压在 usr/local/nginx目录下。<br>所以启动的时候：usr/local/nginx/sbin/nginx -c  /usr/local/nginx/conf/nginx.conf<br>-c在这里是指定配置文件的路径，如果不指定，那么就是默认的<br>/usr/local/nginx/conf/nginx.conf<br>启动后我们可以通过 ps -ef | grep nginx 来查找Nginx的主进程号<br>master process代表住进程</p>
<p>Windows下直接点击解压包中的nginx.exe </p>
<h3 id="Nginx的停止"><a href="#Nginx的停止" class="headerlink" title="Nginx的停止"></a>Nginx的停止</h3><p>1) 从容停止Nginx<br>kill - QUIT <nginx 主进程号=""><br>或 kill - QUIT ‘/usr/local/nginx/logs/nginx.pid’<br>2) 快速停止Nginx<br>kill - TEAM <nginx 主进程号=""><br>kill - TEAM Nginx ‘/usr/local/nginx/logs/nginx.pid’<br>或<br>kill - INT <nginx 主进程号=""><br>kill - INT ‘/usr/local/nginx/logs/nginx.pid’<br>3) 强制停止所有Nginx进程<br>pkill -9 nginx<br>4) Nginx的平滑重启(因为是从容地重启，因此服务是不中断的)<br>kill - HUP <nginx 主进程号=""><br>kill - HUP ‘/usr/local/nginx/logs/nginx.pid’</nginx></nginx></nginx></nginx></p>
<p>Windows下退出直接在任务管理器停止进程即可</p>
<h2 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h2><p>由于Nginx做两个tomcat的反向代理和负载均衡，所以需要修改两个Tomcat的配置，只需要将两个Tomcat的端口号修改为指定端口号。<br>此处有三处需要修改端口号(修改文件为：apache-tomcat-XXX/conf/server.xml)：</p>
<pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;
&lt;Server port=&quot;18005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;
  &lt;GlobalNamingResources&gt;
    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;
              type=&quot;org.apache.catalina.UserDatabase&quot;
              description=&quot;User database that can be updated and saved&quot;
              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;
              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;
  &lt;/GlobalNamingResources&gt;
  &lt;Service name=&quot;Catalina&quot;&gt;
    &lt;Connector port=&quot;18080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; /&gt;
    &lt;Connector port=&quot;18009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;
       &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;resourceName=&quot;UserDatabase&quot;/&gt;
      &lt;/Realm&gt;
      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;
      &lt;/Host&gt;
    &lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre><p>一共三处 另一个tomcat改为 28005、28080、28009即可<br>配置Nginx<br>注：配置文件是nginx.conf文件</p>
<pre><code>worker_processes  2;#工作进程的个数，一般与计算机的cpu核数一致，或者是双倍
events {
    worker_connections  1024;#单个进程最大连接数（最大连接数=连接数*进程数）
}
http {
    include       mime.types; #文件扩展名与文件类型映射表
    default_type  application/octet-stream;#默认文件类型
    sendfile        on;#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    keepalive_timeout  65; #长连接超时时间，单位是秒
    gzip  on;#启用Gizp压缩
    #服务器的集群
    upstream  netitcast.com {  #服务器集群名字  此处是两个tomcat
        server    127.0.0.1:18080  weight=1;#服务器配置   weight是权重的意思，权重越大，分配的概率越大。
        server    127.0.0.1:28080  weight=2;
    }    
    #当前的Nginx的配置
    server {
        listen  80;#监听80端口，可以改成其他端口
        server_name  localhost;##############    当前服务的域名
    location / {
            proxy_pass http://netitcast.com;
            proxy_redirect default;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
</code></pre><h2 id="关闭日志操作-可选"><a href="#关闭日志操作-可选" class="headerlink" title="关闭日志操作(可选)"></a>关闭日志操作(可选)</h2><p>由于我们的服务需要在服务器上长久运行，日志文件的产生会导致服务器硬盘空间的不足，并且会对系统稳定性造成一定影响，所以我们可以选择关掉日志文件。</p>
<h3 id="Tomcat日志关闭"><a href="#Tomcat日志关闭" class="headerlink" title="Tomcat日志关闭"></a>Tomcat日志关闭</h3><p>将server.xml下的</p>
<pre><code>&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
           prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
           pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;
</code></pre><p>注释掉即可。</p>
<h3 id="Nginx日志关闭"><a href="#Nginx日志关闭" class="headerlink" title="Nginx日志关闭"></a>Nginx日志关闭</h3><pre><code>开发环境我默认不写日志，即不配置任何access_log
Nginx的http段中，设置access log：access_log off;
其他日志可以百度查找相关方法
</code></pre><p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nginx的简介&quot;&gt;&lt;a href=&quot;#Nginx的简介&quot; class=&quot;headerlink&quot; title=&quot;Nginx的简介&quot;&gt;&lt;/a&gt;Nginx的简介&lt;/h2&gt;&lt;p&gt;Nginx 是一个很强大的高性能Web和反向代理服务器。&lt;/p&gt;
&lt;h2 id=&quot;Nginx优点&quot;&gt;&lt;a href=&quot;#Nginx优点&quot; class=&quot;headerlink&quot; title=&quot;Nginx优点&quot;&gt;&lt;/a&gt;Nginx优点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率。在高连接并发的情况下，Nginx是Apache服务器不错的替代品，能够支持高达 50000 个并发连接数的响应。&lt;/li&gt;
&lt;li&gt;Nginx 配置简洁, Apache 复杂 ，Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 . Nginx 静态处理性能比 Apache 高 3倍以上 ，Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端来使用 ,Apache 的组件比 Nginx 多. &lt;/li&gt;
&lt;li&gt;最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；Nginx是异步的，多个连接（万级别）可以对应一个进程 .&lt;/li&gt;
&lt;li&gt;Nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用Nginx作为反向代理抗住压力，apache作为后端处理动态请求。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://tomatoyan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://tomatoyan.github.io/2017/08/01/hello-world/"/>
    <id>http://tomatoyan.github.io/2017/08/01/hello-world/</id>
    <published>2017-08-01T06:02:18.000Z</published>
    <updated>2017-08-31T06:10:22.384Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<a id="more"></a>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://tomatoyan.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>

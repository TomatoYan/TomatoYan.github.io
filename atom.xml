<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>泛泛而谈</title>
  <subtitle>大抵浮生若梦，姑且此处销魂。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tomatoyan.github.io/"/>
  <updated>2017-12-15T06:13:07.699Z</updated>
  <id>http://tomatoyan.github.io/</id>
  
  <author>
    <name>Tomato Yan</name>
    <email>632068499@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>沉淀</title>
    <link href="http://tomatoyan.github.io/2017/12/15/%E6%B2%89%E6%B7%80/"/>
    <id>http://tomatoyan.github.io/2017/12/15/沉淀/</id>
    <published>2017-12-15T06:37:02.000Z</published>
    <updated>2017-12-15T06:13:07.699Z</updated>
    
    <content type="html"><![CDATA[<p>像是一种反思，最近生活过的很快，可能安逸会让人变得懒散可怕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像是一种反思，最近生活过的很快，可能安逸会让人变得懒散可怕。&lt;/p&gt;

    
    </summary>
    
    
      <category term="生活" scheme="http://tomatoyan.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java中的四种引用</title>
    <link href="http://tomatoyan.github.io/2017/10/27/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>http://tomatoyan.github.io/2017/10/27/Java中的四种引用/</id>
    <published>2017-10-27T07:51:00.000Z</published>
    <updated>2017-12-15T05:24:18.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>强引用的特点：</p>
<pre><code>1.强引用可以直接访问目标对象。
2.强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OutOfMemmory也不会回收强引用所指的对象。
3.强引用可能会导致内存泄漏。
例如：StringBuilder str = new StringBuilder(&quot;Hello World&quot;);
str 是强引用。
  ● 将对象的引用显示地置为null：str=null;     // 帮助垃圾收集器回收此对象
</code></pre><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><pre><code>可以通过 java.lang.ref.SoftReference 使用软引用，一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆使用率临近阀值时，才会去回收软引用的对象。只要有足够的内存，软引用便可能在内存中存活相当长的一段时间。
软引用可以用于实现内存敏感的Cache。
SoftReference&lt;String&gt; softRef = new SoftReference&lt;String&gt;(&quot;Hello World&quot;);
</code></pre><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><pre><code>在系统GC的时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。但由于垃圾回收线程的优先级很低，因此，并不一定能很快地发现持有弱引用的对象，在这种情况下，弱引用对象可以存在较长时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到另一个注册引用队列中。WeakReference&lt;String&gt; weakRef = new WeakReference&lt;String&gt;(&quot;HelloWorld&quot;);
</code></pre><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><pre><code>一个持有虚引用的对象，和没有引用几乎是一样的，随时可能被垃圾回收。

强引用 =&gt; 软引用 =&gt; 弱引用 =&gt; 虚引用
</code></pre><h2 id="引用的作用："><a href="#引用的作用：" class="headerlink" title="引用的作用："></a>引用的作用：</h2><pre><code>有些需要设定引用回收策略的，就可以设置为强/软/弱/虚引用，没必要自己写回收策略，直接交给GC来做，根据引用的特性回收。
</code></pre><ol>
<li>在非常关心内存的情况下，有可能能派上用场。</li>
<li><p>在涉及到某一个对象被 GC，需要得到通知，然后再做某些相关处理的时候，有可能派得上用场。</p>
<p>一些涉及到的环节，比如 建立Connection连接后要关闭连接，也就是将连接赋值为null，就是为了方便GC去回收。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引用类型&quot;&gt;&lt;a href=&quot;#引用类型&quot; class=&quot;headerlink&quot; title=&quot;引用类型&quot;&gt;&lt;/a&gt;引用类型&lt;/h2&gt;&lt;h3 id=&quot;强引用&quot;&gt;&lt;a href=&quot;#强引用&quot; class=&quot;headerlink&quot; title=&quot;强引用&quot;&gt;&lt;/a&gt;强引
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>近期读书</title>
    <link href="http://tomatoyan.github.io/2017/10/25/%E8%BF%91%E6%9C%9F%E8%AF%BB%E4%B9%A6/"/>
    <id>http://tomatoyan.github.io/2017/10/25/近期读书/</id>
    <published>2017-10-25T12:05:50.000Z</published>
    <updated>2017-12-15T05:37:42.152Z</updated>
    
    <content type="html"><![CDATA[<p>读书的记录：</p>
<pre><code>因为好多书值得多次看，但很多时候看了一次就忘记哪些书很好，哪里好，哪里值得多次再看，因此得以记录。
</code></pre><p>按时间排序：</p>
<pre><code>1. Java编程思想  或许更适合初学者，看过两次，没什么感觉。基本都是基础的语法知识。
2. 深入JVM虚拟机  前几章可能更值得多看，后面的太深入了，目前不是很懂。
3. 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读书的记录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;因为好多书值得多次看，但很多时候看了一次就忘记哪些书很好，哪里好，哪里值得多次再看，因此得以记录。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按时间排序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. Java编程思想  或许更适合初学者，看过两次，
    
    </summary>
    
    
      <category term="随笔" scheme="http://tomatoyan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨Java字符串的拼接</title>
    <link href="http://tomatoyan.github.io/2017/10/02/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5/"/>
    <id>http://tomatoyan.github.io/2017/10/02/深入探讨Java字符串的拼接/</id>
    <published>2017-10-02T07:20:10.000Z</published>
    <updated>2017-10-03T01:48:16.298Z</updated>
    
    <content type="html"><![CDATA[<pre><code>前言：国庆最近跟着小男友在图书馆学习，偶然被他带着看开了Java源码，因而有兴趣想看看String这个是怎么回事。
</code></pre><h1 id="String中的equals"><a href="#String中的equals" class="headerlink" title="String中的equals"></a>String中的equals</h1><pre><code>public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
</code></pre><a id="more"></a>
<p>这是String复写的equals的源码，在Object中equals方法返回的是两者地址值，即：</p>
<pre><code>public boolean equals(Object obj) {
    return (this == obj);
}
</code></pre><p>也就是说，如果这两个地址相同则返回true，不进行内容的比较。例如，</p>
<pre><code>String s1 = &quot;abc&quot;;
String s2 = &quot;abc&quot;;
</code></pre><p>由于这两个变量都在常量池，所以地址会一致，所以返回true。之后的判断也一目了然，首先判断是否属于String类，然后判断内容是否一致。</p>
<h1 id="String中的HashCode"><a href="#String中的HashCode" class="headerlink" title="String中的HashCode"></a>String中的HashCode</h1><pre><code>hashcode是何许物种？我们可以查到一种解释，hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值，在Object中也可以看到对HashCode生成的方法，是一个native类，但好在有注释，Whenever it is invoked on the same object more than once during an execution of a Java application, the method must consistently return the same integer.底层是C++的实现，但总而言之，是可以用它确定对象地址是否相同的。
</code></pre><p>在String类中，复写了hashCode的生成方法，显得简单了很多，这里的hashcode将String字符串经过计算得到了一个数字，计算方法如下：</p>
<pre><code>public int hashCode() {
    int h = hash;
    if (h == 0 &amp;&amp; value.length &gt; 0) {
        char val[] = value;

        for (int i = 0; i &lt; value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
</code></pre><p>也就是将每个字符转成ASCII码，通过公式算得。例如：</p>
<pre><code>String str = &quot;abc&quot;;
System.out.println(str.hashCode());
System.out.println(31*((31*97)+98)+99);
即为：96354
同时我们可以看出字符串a的hashcode为97
System.out.println(&quot;a&quot;.hashCode()); ==&gt; 97
</code></pre><p>其实有很多类都复写了hashcode方法，例如Integer，直接返回了Integer的值。</p>
<pre><code>public int hashCode() {
    return Integer.hashCode(value);
}
</code></pre><h1 id="String中的-拼接"><a href="#String中的-拼接" class="headerlink" title="String中的 + 拼接"></a>String中的 + 拼接</h1><p>终于引出来我们最需要了解的一个方法了。</p>
<pre><code>引出今天探索的原因是String是一个被final修饰的类
    public final class String
所以，我就在想，通过 + 的字符拼接是怎么进行的，== 是判断地址的，那么由于String是一个不可变的类，也就是说，+ 拼接完后的String还是不是它本身。
如代码：
    String s = &quot;hello&quot;;
    String str = &quot;hello&quot;;
    System.out.println(s==str);
    s+=&quot;world&quot;;
    System.out.println(s==str);
假设s的地址没有发生改变的话，那么两个判断都应该是true，然而结果是第一个是true，第二个是false，我们也就可以这样猜想，是不是这个拼接后的s，已经不是之前的s。

之后我们又进行了如下测试，返回值是false，也就是说，str1与str2地址不同，这个很好理解，因为是new操作，所以hello就存放在了两个堆区，同时str1和str2的地址值存放到了栈中。
    String str1 = new String(&quot;hello&quot;);
    String str2 = new String(&quot;hello&quot;);
    System.out.println(str1 == str2);
</code></pre><p><img src="http://img.blog.csdn.net/20171003094536602?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>通过反编译代码，可以发现String中 + 进行拼接，实际上是创建了一个StringBuilder，事实上这个我还真没反编译出来，网上找到的参考资料如下：</p>
<pre><code>String str0 = &quot;a&quot;;
StringBuilder sb = new StringBuilder();
sb.append(str0).append(&quot;b&quot;);
String str1 = sb.toString();

来自：http://www.jianshu.com/p/849f1d443b3a
</code></pre><p>所以，String引用对象在拼接时，建立了临时缓存的StringBuilder，因此地址发生了变化。</p>
<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;前言：国庆最近跟着小男友在图书馆学习，偶然被他带着看开了Java源码，因而有兴趣想看看String这个是怎么回事。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;String中的equals&quot;&gt;&lt;a href=&quot;#String中的equals&quot; class=&quot;headerlink&quot; title=&quot;String中的equals&quot;&gt;&lt;/a&gt;String中的equals&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://tomatoyan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习(一)</title>
    <link href="http://tomatoyan.github.io/2017/08/28/MongoDB%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <id>http://tomatoyan.github.io/2017/08/28/MongoDB学习-一/</id>
    <published>2017-08-28T05:14:52.000Z</published>
    <updated>2017-08-31T06:13:31.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><pre><code>文档是MongoDB中数据的基本单元，类似于关系数据库中的行。
集合可以被看做是没有模式的表。
MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限。
每一个文档都有一个特殊的键 “_id” ，它在文档所处的集合中是唯一的。
</code></pre><h2 id="文档概念"><a href="#文档概念" class="headerlink" title="文档概念"></a>文档概念</h2><ul>
<li>文档中的键 / 值对是有序的，上面的文档和下面的文档是完全不同的；</li>
<li>文档的键是字符串，键不能含有 \0 ，这个字符用来表示键的结尾；</li>
<li>MongoDB不但区分类型，还区分大小写；</li>
<li>MongoDB不允许有重复的键；</li>
<li>集合就是一组文档；</li>
<li>集合是无模式的；</li>
</ul>
<a id="more"></a>
<h2 id="集合概念"><a href="#集合概念" class="headerlink" title="集合概念"></a>集合概念</h2><ul>
<li>集合名不能是空字符串 “”；</li>
<li>集合名不能含有 \0 字符串，这个字符表示集合名的结尾；</li>
<li>集合名不能以“system”开头，这是为系统保留的前缀；</li>
<li>用户创建的集合名字不能含有保留字符 $ ；</li>
</ul>
<h2 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h2><p>MongoDB中多个文档组成集合，同样多个集合组成数据库。一个MongoDB实例可以承载多个数据库，每个数据库拥有0个或多个集合，它们之间可以视为完全独立的。每个数据库有独立的权限控制。<br>数据库名满足的条件：</p>
<ul>
<li>不能是空字符串</li>
<li>不能含有空格，. ，$，/，\，\0</li>
<li>应全部小写</li>
<li>最多64字节</li>
</ul>
<p>特殊作用的数据库：</p>
<ul>
<li>dmin：从权限看，这是“root”数据库，一些特定的服务端命令也只能从这个数据库运行。</li>
<li>local：这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config：当Mongo用于分片设置时，cnfig数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>启动MongoDB，由于MongoDB一般作为网络服务器来运行，客户端可以连接到该服务器并执行操作，要启动该服务器，需要运行mongod可执行文件。mongod在没有参数的情况下会使用默认数据目录/data/db，并使用27017端口，如果目录不存在或不可写，服务器会启动失败，如果端口被占用也会启动失败。<br>MongoDB会自带一个JavaScript shell，可以从命令行与MongoDB实例交互。运行mongo启动shell。</p>
<h2 id="Shell的基本操作"><a href="#Shell的基本操作" class="headerlink" title="Shell的基本操作"></a>Shell的基本操作</h2><p>创建、读取、更新、删除(CRUD)。</p>
<h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h3><p>insert函数添加一个文档到集合当中。</p>
<pre><code>post = {
&quot;title&quot;: &quot;My Blog post&quot;,
&quot;content&quot;: &quot;My content&quot;,
&quot;date&quot;: &quot;2014 4 4 14:44:44&quot;
}
</code></pre><p>post对象是一个有效的MongoDB文档，所以可以采用insert保存到blog集合中：<br>db.blog.insert(post)</p>
<h3 id="2-读取"><a href="#2-读取" class="headerlink" title="2. 读取"></a>2. 读取</h3><p>find会返回集合里面的所有文档，若只想查看一个文档，可以选择findOne：<br>db.blog.findOne()<br>使用find时，shell自动显示最多20个匹配文档。<br>db.blog.find()</p>
<h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3. 更新"></a>3. 更新</h3><p>update接受(至少)两个参数：第一个是要更新文档的限定条件，第二个是更新的文档。<br>假设，我们需要在先前的文章增加评论内容，则需要增加一个新的键，<br>post.comments = []<br>然后执行update操作，用新版的文档替换标题为“My Blog post”的文章</p>
<pre><code>db.blog.update({title: &quot;My Blog post&quot;}, post)
{
    &quot;_id&quot; : ObjectId(&quot;59a622650eac87b27720f544&quot;),
    &quot;title&quot; : &quot;My Blog post&quot;,
    &quot;content&quot; : &quot;My content&quot;,
    &quot;date&quot; : &quot;2014 4 4 14:44:44&quot;,
    &quot;comments&quot; : [ ]
}
</code></pre><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h3><p>remove用来从数据库中永久地删除文档，在不使用参数进行调用的情况下，它会删除一个集合内的所有文档。它也可以接受一个文档以指定限定条件。</p>
<pre><code>db.blog.remove({title: &quot;My Blog post&quot;})
</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在shell中，只有db中找不到指定的属性时，才会将其作为集合返回。<br>例如version是数据库函数，</p>
<pre><code>&gt; db.version
function(){
return this.serverBuildInfo.version;
}
</code></pre><p>当有属性值与目标集合同名时，可以使用getCollection函数：</p>
<pre><code>&gt; db.getCollection(&quot;version&quot;);
test.version
db.getCollection(&quot;version&quot;).find() 便会返回集合version中的数据
</code></pre><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><p>MongoDB的文档类似于JSON，在概念上与JavaScript中的对象相似。<br>JSON仅包含6种数据类型，null、布尔、数字、字符串、数组、对象。<br>MongoDB在保留JSON基本键值对的基础上，添加了其他的一些数据类型，</p>
<ul>
<li>null 用来表示空值或者不存在的字段   {“x”: null}</li>
<li>布尔 有两个值 ‘true’ 和 ‘false’   {“x”: true}</li>
<li>32 位整数 shell中这个类型不可用，因为JavaScript仅支持64位浮点数，所以32位整数会被自动转换</li>
<li>64位整数 shell中不支持这个类型，shell会使用一个特殊的内嵌文档来显示64位整数</li>
<li>64位浮点数 shell中的数字都是这个类型</li>
<li>字符串 UTF-8字符串都可以表示为字符串类型的数据</li>
<li>符号 shell不支持这种类型，shell将数据库里的符号类型转换成字符串</li>
<li>对象id 对象id是文档的12字节的唯一ID   {“x”: ObjectId()}</li>
<li>日期 日期类型存数的时从标准纪元开始的毫秒数，不存储时区   {“x”: new Date()}</li>
<li>正则表达式 采用JavaScript的正则表达式的语法   {“x”: /footbar/i}</li>
<li>代码 文档中可以有JavaScript代码   {“x”: function{/<em> … </em>/}}</li>
<li>二进制数据 二进制数据可以由任意字节的串组成，shell中没有这个类型</li>
<li>最大值 BSON包含一个特殊类型，表示可能的最大值，shell中没有这个类型</li>
<li>最小值 BSON包含一个特殊类型，表示可能的最小值，shell中没有这个类型</li>
<li>未定义 文档中也可以用未定义类型(JavaScript中null和undefined是不同的类型)   {“x”: undefined}</li>
<li>数组 值的集合或者列表可以表示成数组   {“x”: [“a”, “b”, “c”]}</li>
<li>内嵌文档 文档可以包含别的文档，也可以作为值嵌入到父文档中   {“x”: {“hello”: “hi”}}</li>
</ul>
<h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于JavaScript中只有一种数字类型，默认情况下shell中的数字都被MongoDB当作是双精度数。这意味着从数据库中获得的是一个32位整数，修改文档后，当文档返回数据库时，这个整数也被转换成了浮点数。<br>在JavaScript中，Date对象用作MongoDB的日期类型，创建一个新的Date对象时，通常调用new Date()，而不只是Date()，调用构造函数实际返回的是对日期的字符串表示，而不是真正的Date对象，如果忘记使用Date构造函数，就会造成日期和字符串的混淆。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MongoDB中存储的文档必须有一个”_id”键。这个键的值可以是任何类型的，默认是个ObjectId对象，在一个集合里，每个文档都有唯一的“_id”值。ObjectId使用12字节的存储空间，每个字节两位十六进制数字，是一个24位的字符串。12字节按照如下方式生成：</p>
<pre><code>0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10 |11
时间戳      | 机器   |PID  | 计数器
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前4个字节是从标准纪元开始的时间戳，单位为秒。由于时间戳在前，这意味着ObjectId会大致按插入顺序排序。<br>接下来3个字节是所在主机的唯一标识符，通常是机器主机名的散列值，保证了不同主机生产不同的ObjectId<br>为了保证同一台机器上并发的多个进程产生的ObjectId是唯一的，之后的2字节来自产生ObjectId的进程标识符(PID)<br>前9字节保证了同一秒钟不同机器不同进程产生的ObjectId是唯一的。后3个字节是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId也是不一样的。<br>同一秒钟最多允许每个进程拥有 256^3（16777216）个不同的ObjectId。</p>
<h3 id="自动生成-id"><a href="#自动生成-id" class="headerlink" title="自动生成_id"></a>自动生成_id</h3><p>如果插入文档的时候并没有 _id 键，系统会自动创建一个，这个操作通常会在客户端由驱动程序完成。</p>
<ul>
<li>虽然ObjectId设计为轻量型，但生成毕竟是还是会产生开销。在客户端生成体现了MongoDB的设计理念，能从服务器端转移到驱动程序来做的事，就尽量转移。将事务交由客户端来处理，就减轻了数据库扩展的负担。</li>
<li><p>在客户端生成ObjectId，驱动程序能够提供更加丰富的API。</p>
<h2 id="使用MongoDBshell"><a href="#使用MongoDBshell" class="headerlink" title="使用MongoDBshell"></a>使用MongoDBshell</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动mongo shell时不连接到任何mongod，可以通过 –nodb 参数启动。启动之后，在需要时运行new Mongo(hostname) 命令就可以连接到想要的mongod了。</p>
<blockquote>
<p>conn = new Mongo(“localhost:27017”)   // 连接本地操作<br>  connection to localhost:27017<br>db = conn.getDB(“test”)   // test 为数据库名<br>  test</p>
</blockquote>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shell内置了帮助文档，可以使用help命令来查看。可以通过 db.help() 查看数据库级别的帮助。</p>
<h3 id="使用shell执行脚本"><a href="#使用shell执行脚本" class="headerlink" title="使用shell执行脚本"></a>使用shell执行脚本</h3><pre><code>$ mongo script1.js script2.js script3.js
mongo shell会依次执行传入的脚本，然后退出。
如果希望指定主机/端口上的mongod运行脚本，需要先指定地址，然后再跟上脚本文件的名称：$ mongo --quiet localhost:27017/test script1.js
这样可以将db指向 localhost:27017上的test数据库，然后运行 script1.js 脚本。
也可以用load()函数，从交互式shell中运行脚本：
&gt; load(&quot;script1.js&quot;)
shell辅助函数对应的JavaScript函数
辅助函数等价函数use 数据库名db.getSisterDB(&quot;数据库名&quot;)show dbsdb.getMongo().getDBs()show collectionsdb.getCollectionNames()
</code></pre><h3 id="创建-mongorc-js-文件"><a href="#创建-mongorc-js-文件" class="headerlink" title="创建 .mongorc.js 文件"></a>创建 .mongorc.js 文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某些脚本会被频繁加载，可以将它们添加到 mongorc.js 文件中。这个文件会在启动shell时自动运行。</p>
<pre><code>例如：我们希望启动成功时让shell显示一句欢迎语，为此我们在用户主目录下创建一个名为
.mongorc.js 的文件，向其中添加如下内容：
// mongorc.js
var compliment = [&quot;atteactive&quot;, &quot;intelligent&quot;, &quot;like Batman&quot;];
var index = Math.floor(Math.random()*3);
print(&quot;Hello, you&apos;re looking particularly &quot;+compliment[index]+&quot; today!&quot;)
然后，当启动shell时，就会看到这样一些内容：
$ mongo
MongoDB shell version v3.4.4
Hello, you&apos;re looking particularly like Batman today！
</code></pre><h3 id="定制shell提示"><a href="#定制shell提示" class="headerlink" title="定制shell提示"></a>定制shell提示</h3><pre><code>在 .mongorc.js 文件中将prompt变量设为一个字符串或者函数，就可以重写默认的shell提示。
显示当前时间：
prompt = function(){
return (new Date())+&quot;&gt;&quot;;
};
提示当前使用的数据库：
prompt = function(){
if(typeof db == &apos;undefined&apos;){
return &apos;(nodb)&gt;&apos;;
}
// 检查最后的数据库操作
try{
db.runCommand({getLastError:1});
}catch(e){
print(e);
}
return db+&quot;&gt;&quot;;
};
</code></pre><p>&lt;!- end -&gt;</p>
<p><br><br><br><br><br><br><br><br><br><br><br>读书笔记 — MongoDB权威指南 转载表明出处 TomatoYan<br><!--戎戎 我喜欢你--></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;文档是MongoDB中数据的基本单元，类似于关系数据库中的行。
集合可以被看做是没有模式的表。
MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限。
每一个文档都有一个特殊的键 “_id” ，它在文档所处的集合中是唯一的。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;文档概念&quot;&gt;&lt;a href=&quot;#文档概念&quot; class=&quot;headerlink&quot; title=&quot;文档概念&quot;&gt;&lt;/a&gt;文档概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文档中的键 / 值对是有序的，上面的文档和下面的文档是完全不同的；&lt;/li&gt;
&lt;li&gt;文档的键是字符串，键不能含有 \0 ，这个字符用来表示键的结尾；&lt;/li&gt;
&lt;li&gt;MongoDB不但区分类型，还区分大小写；&lt;/li&gt;
&lt;li&gt;MongoDB不允许有重复的键；&lt;/li&gt;
&lt;li&gt;集合就是一组文档；&lt;/li&gt;
&lt;li&gt;集合是无模式的；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mongoDB" scheme="http://tomatoyan.github.io/tags/mongoDB/"/>
    
      <category term="读书笔记" scheme="http://tomatoyan.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的安装</title>
    <link href="http://tomatoyan.github.io/2017/08/23/MongoDB%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://tomatoyan.github.io/2017/08/23/MongoDB的安装/</id>
    <published>2017-08-23T11:40:57.000Z</published>
    <updated>2017-08-31T06:10:53.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mongodb-Linux下的安装"><a href="#mongodb-Linux下的安装" class="headerlink" title="mongodb Linux下的安装"></a>mongodb Linux下的安装</h1><h2 id="下载mongodb"><a href="#下载mongodb" class="headerlink" title="下载mongodb"></a>下载mongodb</h2><pre><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.4.7.tgz
</code></pre><h2 id="解压mongodb安装包"><a href="#解压mongodb安装包" class="headerlink" title="解压mongodb安装包"></a>解压mongodb安装包</h2><pre><code>tar -zxvf mongodb-linux-x86_64-amazon-3.4.7.tgz
</code></pre><h2 id="将解压后的文件移动到指定目录-可选"><a href="#将解压后的文件移动到指定目录-可选" class="headerlink" title="将解压后的文件移动到指定目录(可选)"></a>将解压后的文件移动到指定目录(可选)</h2><pre><code>mv mongodb-linux-x86_64-amazon-3.4.7/  /usr/local/mongodb
</code></pre><a id="more"></a>
<h2 id="配置环境变量："><a href="#配置环境变量：" class="headerlink" title="配置环境变量："></a>配置环境变量：</h2><pre><code>vim ~/.bashrc  添加如下内容：
export MONGODB_HOME=/usr/local/mongodb
export PATH=$MONGODB_HOME/bin:$PATH

配置生效： source ~/.bashrc
mongod -v 查看mongodb版本信息查看环境变量是否配置正确
</code></pre><h2 id="创建数据库目录："><a href="#创建数据库目录：" class="headerlink" title="创建数据库目录："></a>创建数据库目录：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录,注意：如果你的数据库目录不是/data/db，可以通过 –dbpath 来指定<br>mkdir -p /data/db<br>mkdir -p /data/log<br>touch /data/log/mongodb.log</p>
<h3 id="添加配置文件："><a href="#添加配置文件：" class="headerlink" title="添加配置文件："></a>添加配置文件：</h3><pre><code>touch /etc/conf/mongodb.conf
新建mongodb.conf配置文件
vim /etc/conf/mongodb.conf
</code></pre><h3 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h3><pre><code>dbpath=/data/db
logpath=/data/log/mongodb.log
logappend=true
port=27017
&lt;!-- 配置放在其他位置没有试过 --&gt;
</code></pre><h3 id="配置文件参数说明"><a href="#配置文件参数说明" class="headerlink" title="配置文件参数说明:"></a>配置文件参数说明:</h3><h4 id="mongodb的参数说明："><a href="#mongodb的参数说明：" class="headerlink" title="mongodb的参数说明："></a>mongodb的参数说明：</h4><pre><code>--dbpath 数据库路径(数据文件)
--logpath 日志文件路径
--master 指定为主机器
--slave 指定为从机器
--source 指定主机器的IP地址
--pologSize 指定日志文件大小不超过64M.因为resync是非常操作量大且耗时，最好通过设置一个足够大的oplogSize来避免resync(默认的 oplog大小是空闲磁盘大小的5%)。
--logappend 日志文件末尾添加
--port 启用端口号
--fork 在后台运行
--only 指定只复制哪一个数据库
--slavedelay 指从复制检测的时间间隔
--auth 是否需要验证权限登录(用户名和密码)
</code></pre><h2 id="通过配置文件启动服务："><a href="#通过配置文件启动服务：" class="headerlink" title="通过配置文件启动服务："></a>通过配置文件启动服务：</h2><pre><code>mongod --journal -f /etc/mongodb.conf  --fork (32位系统需要加参数 --journal  fork后台运行服务) 
</code></pre><h2 id="通过配置文件关闭服务："><a href="#通过配置文件关闭服务：" class="headerlink" title="通过配置文件关闭服务："></a>通过配置文件关闭服务：</h2><pre><code>mongod --journal --shutdown -f /etc/mongodb.conf
可以省略为 mongod --shutdown
</code></pre><h2 id="通过命令行启动服务："><a href="#通过命令行启动服务：" class="headerlink" title="通过命令行启动服务："></a>通过命令行启动服务：</h2><pre><code>mongod --dbpath=/data/db/ --logpath=/data/log/mongodb.log --fork
</code></pre><h2 id="进入mongodb后台管理shell"><a href="#进入mongodb后台管理shell" class="headerlink" title="进入mongodb后台管理shell"></a>进入mongodb后台管理shell</h2><pre><code>进入bin目录 cd /usr/local/mongodb/bin
执行   ./mongo
</code></pre><h3 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h3><pre><code>命令： use test
switched to db test
</code></pre><h3 id="创建用户，设置权限"><a href="#创建用户，设置权限" class="headerlink" title="创建用户，设置权限"></a>创建用户，设置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">user:&quot;test&quot;,&lt;br&gt;</div><div class="line">pwd:&quot;test&quot;, &lt;br&gt;</div><div class="line">roles:[&#123;role:&quot;readWrite&quot;, db:&quot;test&quot;&#125;]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170827185436097?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="mongodb-web界面"><a href="#mongodb-web界面" class="headerlink" title="mongodb web界面"></a>mongodb web界面</h2><pre><code>mongod -f /etc/mongodb.conf --rest
在地址栏输入 127.0.0.1:28017     注意，端口号会比默认设定增加100
</code></pre><h1 id="Window下的安装"><a href="#Window下的安装" class="headerlink" title="Window下的安装"></a>Window下的安装</h1><h2 id="首先下载安装包"><a href="#首先下载安装包" class="headerlink" title="首先下载安装包"></a>首先下载安装包</h2><p><img src="http://img.blog.csdn.net/20170827185532993?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170827185602246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170827185626674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<pre><code>此时已经有了一个db的文件夹
</code></pre><h2 id="在Windows下运行MongoDB服务器"><a href="#在Windows下运行MongoDB服务器" class="headerlink" title="在Windows下运行MongoDB服务器"></a>在Windows下运行MongoDB服务器</h2><pre><code>1. 进入MongoDB下的bin目录
2. 执行mongod.exe 文件
.\mongod.exe --dbpath &quot;C:\Programs\mongodb_sample\data\db&quot;
&quot;C:\Programs\mongodb_sample\data\db&quot; 是数据库的文件目录
3. 执行成功会有如下的输出：
</code></pre><p><img src="http://img.blog.csdn.net/20170827185657764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<pre><code>然后打开新的窗口输入  .\mongo.exe即可进入mongodb服务器
</code></pre><p><img src="http://img.blog.csdn.net/20170827185825745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mongodb-Linux下的安装&quot;&gt;&lt;a href=&quot;#mongodb-Linux下的安装&quot; class=&quot;headerlink&quot; title=&quot;mongodb Linux下的安装&quot;&gt;&lt;/a&gt;mongodb Linux下的安装&lt;/h1&gt;&lt;h2 id=&quot;下载mongodb&quot;&gt;&lt;a href=&quot;#下载mongodb&quot; class=&quot;headerlink&quot; title=&quot;下载mongodb&quot;&gt;&lt;/a&gt;下载mongodb&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.4.7.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;解压mongodb安装包&quot;&gt;&lt;a href=&quot;#解压mongodb安装包&quot; class=&quot;headerlink&quot; title=&quot;解压mongodb安装包&quot;&gt;&lt;/a&gt;解压mongodb安装包&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;tar -zxvf mongodb-linux-x86_64-amazon-3.4.7.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;将解压后的文件移动到指定目录-可选&quot;&gt;&lt;a href=&quot;#将解压后的文件移动到指定目录-可选&quot; class=&quot;headerlink&quot; title=&quot;将解压后的文件移动到指定目录(可选)&quot;&gt;&lt;/a&gt;将解压后的文件移动到指定目录(可选)&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;mv mongodb-linux-x86_64-amazon-3.4.7/  /usr/local/mongodb
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="mongoDB" scheme="http://tomatoyan.github.io/tags/mongoDB/"/>
    
  </entry>
  
  <entry>
    <title>jvisualvm远程监控Tomcat</title>
    <link href="http://tomatoyan.github.io/2017/08/09/jvisualvm%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7Tomcat/"/>
    <id>http://tomatoyan.github.io/2017/08/09/jvisualvm远程监控Tomcat/</id>
    <published>2017-08-09T10:02:17.000Z</published>
    <updated>2017-08-31T06:10:40.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VisualVM(All-in-One Java Trouble Tool)是到目前为止随JDK发布功能最强大的运行监视和故障处理程序。而且VisualVM不需要被监视的程序基于特殊Agent运行，因此它对实际性能的影响很小，使得它可以直接应用在生产环境中。<br>界面如下：<br><img src="http://img.blog.csdn.net/20170809183644088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="界面1"></p>
<a id="more"></a>
<p><img src="http://img.blog.csdn.net/20170809183710495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="界面2"></p>
<h2 id="VisualVM的功能"><a href="#VisualVM的功能" class="headerlink" title="VisualVM的功能"></a>VisualVM的功能</h2><p>VisualVM可以做到：</p>
<ul>
<li>显示虚拟机进程以及进程的配置、环境信息(jsp、jinfo)。</li>
<li>监视应用程序的CPU、GC、堆、方法区以及线程的信息(jstat、jstack)。</li>
<li>dump以及分析堆转储快照(jmap、jhat)。</li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</li>
</ul>
<h2 id="VisualVM安装插件"><a href="#VisualVM安装插件" class="headerlink" title="VisualVM安装插件"></a>VisualVM安装插件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于墙的原因，所以需要采取些措施，才能顺利的下载安装插件。<br><img src="http://img.blog.csdn.net/20170810153927241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="插件"></p>
<h2 id="jvisualvm远程监控Tomcat"><a href="#jvisualvm远程监控Tomcat" class="headerlink" title="jvisualvm远程监控Tomcat"></a>jvisualvm远程监控Tomcat</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入我们的正题，利用jvisualvm远程监控Tomcat服务器。这里的Tomcat部署在远程Linux服务器上。</p>
<h3 id="1-修改Tomcat下bin目录下的startup-sh"><a href="#1-修改Tomcat下bin目录下的startup-sh" class="headerlink" title="1.修改Tomcat下bin目录下的startup.sh"></a>1.修改Tomcat下bin目录下的startup.sh</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在startup.sh倒数第二行，也就是exec “$PRGDIR”/“$EXECUTABLE” start “$@”上一行添加如下内容：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>export CATALINA_OPTS=&quot;$CATALINA_OPTS
-Dcom.sun.management.jmxremote
-Djava.rmi.server.hostname=192.168.1.130
-Dcom.sun.management.jmxremote.port=8888
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=true
-Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password
-Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access&quot;</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;各个参数的说明如下：</p>
<pre><code>-Dcom.sun.management.jmxremote   #启用JMX远程监控
-Djava.rmi.server.hostname=192.168.1.130  #Tomcat服务器地址
-Dcom.sun.management.jmxremote.port=8888  #jmx连接端口
-Dcom.sun.management.jmxremote.ssl=false   #是否ssl加密
-Dcom.sun.management.jmxremote.authenticate=false   #远程连接不需要密码认证
-Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password   #指定连接的用户名和密码配置文件
-Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access   #指定连接的用户所拥有权限的配置文件
</code></pre><h3 id="2-修改服务器上Tomcat的配置："><a href="#2-修改服务器上Tomcat的配置：" class="headerlink" title="2.修改服务器上Tomcat的配置："></a>2.修改服务器上Tomcat的配置：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要修改两个配置文件，首先进入 JAVA_HOME\jre\lib\management 目录下，拷贝和修改jmxremote.password.template为jmxremote.password，操作为：<br>取消最后两行代码的注释，</p>
<pre><code>\# monitorRole  QED   ---&gt;   monitorRole  QED
\# controlRole   R&amp;D   ---&gt;   controlRole   R&amp;D
</code></pre><p>拷贝和修改文件jmxremote.access，操作为：</p>
<pre><code>monitorRole   readonly
controlRole   readwrite
</code></pre><h3 id="3-将文件拷贝至服务器上Tomcat下的conf目录下"><a href="#3-将文件拷贝至服务器上Tomcat下的conf目录下" class="headerlink" title="3.将文件拷贝至服务器上Tomcat下的conf目录下"></a>3.将文件拷贝至服务器上Tomcat下的conf目录下</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即和tomcat的配置文件放在一起</p>
<h3 id="4-修改两个文件权限"><a href="#4-修改两个文件权限" class="headerlink" title="4.修改两个文件权限"></a>4.修改两个文件权限</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改jmxremote.access和jmxremote.password的权限：sudo chmod 600 jmx*</p>
<h3 id="5-重新启动Tomcat"><a href="#5-重新启动Tomcat" class="headerlink" title="5.重新启动Tomcat"></a>5.重新启动Tomcat</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以查看log下的日志看是否有错，并解决。</p>
<h3 id="6-打开jvisualvm"><a href="#6-打开jvisualvm" class="headerlink" title="6.打开jvisualvm"></a>6.打开jvisualvm</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1 添加远程主机 6.2 添加JMX连接 确定连接即可<br><img src="http://img.blog.csdn.net/20170809183806389?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="连接"></p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h2 id="监控JVM中运行的Java程序"><a href="#监控JVM中运行的Java程序" class="headerlink" title="监控JVM中运行的Java程序"></a>监控JVM中运行的Java程序</h2><p>前提：远程机器需要有Java环境</p>
<p>1.在%JAVA_HOME%\bin目录下创建一个文件：jstatd.all.policy（名字可以变，扩展名不可以变），内容如下：</p>
<pre><code>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {
   permission java.security.AllPermission;
};
</code></pre><p>这个文件的作用是让jstatd服务能够读取机器上的java应用程序的运行数据。</p>
<p>2.在%JAVA_HOME%\bin目录下，执行如下命令：</p>
<p>jstatd -J-Djava.security.policy=jstatd.all.policy</p>
<p>3.展开刚所新建的远程主机，就可看到运行在远程机器上的JAVA应用程序了</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstatd.html" title="jstatd - Virtual Machine jstat Daemon" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstatd.html</a></p>
<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VisualVM：多合一故障处理工具&quot;&gt;&lt;a href=&quot;#VisualVM：多合一故障处理工具&quot; class=&quot;headerlink&quot; title=&quot;VisualVM：多合一故障处理工具&quot;&gt;&lt;/a&gt;VisualVM：多合一故障处理工具&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;VisualVM(All-in-One Java Trouble Tool)是到目前为止随JDK发布功能最强大的运行监视和故障处理程序。而且VisualVM不需要被监视的程序基于特殊Agent运行，因此它对实际性能的影响很小，使得它可以直接应用在生产环境中。&lt;br&gt;界面如下：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170809183644088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaV9hbV90b21hdG8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;界面1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="jvm" scheme="http://tomatoyan.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Docker教程</title>
    <link href="http://tomatoyan.github.io/2017/08/07/Docker%E6%95%99%E7%A8%8B/"/>
    <id>http://tomatoyan.github.io/2017/08/07/Docker教程/</id>
    <published>2017-08-07T07:45:12.000Z</published>
    <updated>2017-10-29T08:56:17.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker包括一个命令行程序、一个后台守护进程，以及一组远程服务。它通过Unix的容器技术解决了常见的软件问题，并简化了安装、运行、发布和删除软件。<br>容器不是虚拟化，Docker容器不使用硬件虚拟化，Docker容器中的程序接口和主机的Linux内核直接打交道，容器的运行与计算机操作系统之间没有额外的中间层。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker通过一种打包和分发的软件，完成传统容器的封装。这个充当容器分发角色的组件被称为镜像。Docker镜像是一个容器中运行程序的所有文件的捆绑快照。</p>
<h2 id="Docker解决的问题"><a href="#Docker解决的问题" class="headerlink" title="Docker解决的问题"></a>Docker解决的问题</h2><ol>
<li>组织有序</li>
<li>提高了移植性</li>
<li>保护你的机器<a id="more"></a>
Docker提供了所谓的抽象，抽象允许你以简化的方式处理复杂的工作。但容器不能改善程序的安全。</li>
</ol>
<h2 id="何时何处使用Docker"><a href="#何时何处使用Docker" class="headerlink" title="何时何处使用Docker"></a>何时何处使用Docker</h2><p>Docker应用范围限定在Linux服务器或桌面运行的软件，如Web服务器、邮件服务器、数据库、代理服务器等。</p>
<h2 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h2><p>完成镜像的传输</p>
<ul>
<li>hub.docker.com (速度慢)</li>
<li>c.163.com (网易蜂巢 镜像中心)</li>
<li><a href="https://dev.aliyun.com/search.html" target="_blank" rel="external">https://dev.aliyun.com/search.html</a> (阿里镜像仓库)</li>
<li>镜像也可以搭建内网的镜像中心</li>
</ul>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><pre><code>docker search &lt;镜像名字&gt;     搜索可用的docker镜像    
docker pull &lt;镜像名字&gt;         下载镜像
docker ps       可以查看当前在这台机器上运行的容器
    docker ps -a 查看所有镜像信息
    docker ps -aq 查看所有镜像的id
    docker ps -q 查看所有镜像的id
docker run -d &lt;镜像名&gt;       在后台运行容器，并返回容器的id  -d是detach的缩写
docker run --help        查看docker run的参数
docker exec        进入容器内部  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
docker exec -i         保证我们的输入有效
docker exec -t        分配一个伪终端
docker exec -it f4        两个命令一起运行  由于当前容器运行的镜像非常的少，它就可以通过前两个id判断出是哪个镜像，从而进入这个容器
docker exec 镜像的名称或ID 运行的命令
docker exec -it f4&lt;名字或id&gt; bash    切换到容器内部
docker search &lt;镜像名字&gt;     搜索可用的docker镜像
docker exec -ti &lt;镜像id&gt;  /bin/bash      进入后台容器并提供bash
docker stop &lt;镜像的id或名字&gt;           停掉当前的镜像
docker start &lt;镜像的id或名字&gt;           启动镜像
docker restart      &lt;镜像的id&gt;    重启docker容器
docker rmi &lt;镜像名称&gt; &lt;镜像名称&gt;..    删除一个或者多个镜像
docker rmi -f &lt;镜像名称&gt;        -f = --force    强制删除镜像    
docker ps -a     查看所有容器(包括stop的容器)
docker rm &lt;容器id&gt;        删除指定id的容器
docker stop $(docker ps -q)        停用全部运行中的容器
docker rm $(docker ps -aq)        删除全部容器
docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)     一条命令实现停用并删除容器
</code></pre><h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><pre><code>1.更新镜像之前，我们需要使用镜像来创建一个容器。
2.在运行的容器中使用 apt-get update 命令进行更新，在完成操作之后输入exit命令退出容器。
3.通过docker commit命令来提交容器副本。
</code></pre><p><code>docker commit -m=&quot;has update&quot; -a=&quot;tomato&quot; &lt;镜像id&gt; tomato/ubuntu:v2</code></p>
<pre><code>各个参数说明：
    -m:提交的描述信息
    -a:指定镜像作者
    e218edb10161：容器ID
    tomato/ubuntu:v2:指定要创建的目标镜像名
</code></pre><h2 id="Docker的网络"><a href="#Docker的网络" class="headerlink" title="Docker的网络"></a>Docker的网络</h2><pre><code>Bridge 桥接&lt;默认情况&gt;端口映射
Host 利用主机的IP和端口号
None 不与外界通信
</code></pre><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><ul>
<li>Dockerfile        用来告诉Docker，我制作镜像的每一个步骤</li>
<li>docker build     执行Dockerfile中所描述的每一件事情</li>
</ul>
<p><br></p>
<pre><code>    使用命令 docker build，从零开始来创建一个镜像，我们需要创建一个Dockerfile文件，其中包含一组命令来告诉Docker如何构建镜像。首先创建一个空白的文件夹，mkdir myDocker

FROM    centos:6.7
MAINTAINER      tomato &quot;XXX@XXX.com&quot;
RUN     /bin/echo &apos;root:123456&apos; |chpasswd
RUN     useradd runoob
RUN     /bin/echo &apos;runoob:123456&apos; |chpasswd
RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local
EXPOSE  22
EXPOSE  80
CMD     /usr/sbin/sshd -D
</code></pre><p><br></p>
<pre><code>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。
第一条指令FROM，指定使用哪个镜像源
RUN指令告诉Docker在镜像内执行命令，安装了什么
然后，使用Dockerfile文件，通过docker build命令构建一个镜像。
$ docker build -t tomato/centos:6.7 .

参数说明：
-t：指定创建的目标镜像名
.：Dockerfile文件所在目录，可以指定Dockerfile的绝对路径
</code></pre><p><br></p>
<pre><code>    当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。
所以命令 docker build -t tomato/centos:6.7 . 中的这个 . ，实际上是在指定上下文的目录， docker build 命令会将该目录下的内容打包交给Docker 引擎以帮助构建镜像。
如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：
    $ docker build -t tomato/centos:6.7 .
    Sending build context to Docker daemon 2.048 kB
    ...
理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build打包整个硬盘，这显然是使用错误。
</code></pre><p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker&quot;&gt;&lt;/a&gt;什么是Docker&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Docker包括一个命令行程序、一个后台守护进程，以及一组远程服务。它通过Unix的容器技术解决了常见的软件问题，并简化了安装、运行、发布和删除软件。&lt;br&gt;容器不是虚拟化，Docker容器不使用硬件虚拟化，Docker容器中的程序接口和主机的Linux内核直接打交道，容器的运行与计算机操作系统之间没有额外的中间层。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Docker通过一种打包和分发的软件，完成传统容器的封装。这个充当容器分发角色的组件被称为镜像。Docker镜像是一个容器中运行程序的所有文件的捆绑快照。&lt;/p&gt;
&lt;h2 id=&quot;Docker解决的问题&quot;&gt;&lt;a href=&quot;#Docker解决的问题&quot; class=&quot;headerlink&quot; title=&quot;Docker解决的问题&quot;&gt;&lt;/a&gt;Docker解决的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;组织有序&lt;/li&gt;
&lt;li&gt;提高了移植性&lt;/li&gt;
&lt;li&gt;保护你的机器&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://tomatoyan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>配置最小oracle实例单元</title>
    <link href="http://tomatoyan.github.io/2017/08/07/%E9%85%8D%E7%BD%AE%E6%9C%80%E5%B0%8Foracle%E5%AE%9E%E4%BE%8B%E5%8D%95%E5%85%83/"/>
    <id>http://tomatoyan.github.io/2017/08/07/配置最小oracle实例单元/</id>
    <published>2017-08-07T07:12:56.000Z</published>
    <updated>2017-08-31T06:12:00.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Oracle开发的关系数据库产品因性能卓越而闻名，许多大型网站也选用了Oracle系统，是世界最好的数据库产品。但Oracle数据库管理软件却十分庞大，在本地安装总会开启一堆服务，同时占用大量的磁盘空间和内存。Oracle提供了Oracle SQL Developer这样的管理工具(下载地址: <a href="http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL" target="_blank" rel="external">http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL</a> Developer是Oracle公司出品的一个免费非开源的用以开发数据库应用程序的图形化工具，使用 SQL Developer 可以浏览数据库对象、运行 SQL 语句和脚本、编辑和调试 PL/SQL 语句，但SQL Developer 需要的开发环境要去会比较高(JDK &gt;1.8)，同时，只可以连接到任何Oracle 10g及其后续版本的数据库，此外SQL Developer市场占有率并不高，市场份额基本都被PL/SQL Developer所占有。而PL/SQL Developer 的使用需要有Oracle的一些支持(SQL Developer不需要)，所以我们需要配置最小Oracle实例单元。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h3><pre><code>1.需要在Oracle官网下载简易的oracle数据库客户端(instantclient-basiclite-nt-11.20.0.4.0)，大小仅仅10多M。下载instantclient-basic-win32-11.2.0.1.0
（oracle官网下载地址http://www.oracle.com/technetwork/topics/winsoft-085727.html )
2.下载PL/SQL客户端(官网(https://www.allroundautomations.com/bodyplsqldevreg.html)试用，也可以下载破解版)
</code></pre><h2 id="配置Oracle监听"><a href="#配置Oracle监听" class="headerlink" title="配置Oracle监听"></a>配置Oracle监听</h2><p>解压instantclient-basiclite-nt-11.20.0.4.0 在其文件夹中新建 network 文件夹，新建 admin 文件夹，这个类似oracle数据库的network -&gt; admin，在文件夹中新建 tnsnames.ora 或者从有数据库客户端的地方拷贝。</p>
<pre><code>TEST =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = xxx.xxx.xxx.xxx)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SID = test)
    )
  )
</code></pre><p>也可以直接从oracle客户端里面找到tnsnames.ora文件，直接copy到ADMIN文件下。</p>
<h2 id="设置PL-SQL-Developer"><a href="#设置PL-SQL-Developer" class="headerlink" title="设置PL/SQL Developer"></a>设置PL/SQL Developer</h2><p>打开PLSQL Developer，选择Tools -&gt; perference -&gt; Connection，配置其中的Oracle Home和OCI Library项，如下图所示：</p>
<p><img src="https://ws1.sinaimg.cn/large/be936de3ly1ficcvx09ujj20iv0e5dh4.jpg" alt=""></p>
<pre><code>其中, Oracle Home：E:\app\Administrator\product\instantclient_11_2
     OCI Library：E:\app\Administrator\product\instantclient_11_2\oci.dll
</code></pre><h2 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h2><p>右击”我的电脑” - “属性” - “高级” - “环境变量” - “系统环境变量”:</p>
<pre><code>1&gt;.选择&quot;Path&quot; - 点击&quot;编辑&quot;, 把 &quot;E:\app\Administrator\product\instantclient_11_2;&quot; 加入;
2&gt;.点击&quot;新建&quot;, 变量名设置为&quot;TNS_ADMIN&quot;, 变量值设置为&quot;E:\app\Administrator\product\instantclient_11_2;&quot;, 点击&quot;确定&quot;;
3&gt;.点击&quot;新建&quot;, 变量名设置为&quot;NLS_LANG&quot;, 变量值设置为&quot;SIMPLIFIED CHINESE_CHINA.ZHS16GBK&quot;, 点击&quot;确定&quot;;字符编码变量配置，防止有乱码
</code></pre><p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Oracle开发的关系数据库产品因性能卓越而闻名，许多大型网站也选用了Oracle系统，是世界最好的数据库产品。但Oracle数据库管理软件却十分庞大，在本地安装总会开启一堆服务，同时占用大量的磁盘空间和内存。Oracle提供了Oracle SQL Developer这样的管理工具(下载地址: &lt;a href=&quot;http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)，我们可以使用这个工具对本地和远程的Oracle数据库进行管理，SQL&lt;/a&gt; Developer是Oracle公司出品的一个免费非开源的用以开发数据库应用程序的图形化工具，使用 SQL Developer 可以浏览数据库对象、运行 SQL 语句和脚本、编辑和调试 PL/SQL 语句，但SQL Developer 需要的开发环境要去会比较高(JDK &amp;gt;1.8)，同时，只可以连接到任何Oracle 10g及其后续版本的数据库，此外SQL Developer市场占有率并不高，市场份额基本都被PL/SQL Developer所占有。而PL/SQL Developer 的使用需要有Oracle的一些支持(SQL Developer不需要)，所以我们需要配置最小Oracle实例单元。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://tomatoyan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>澜澜的天上白云飘</title>
    <link href="http://tomatoyan.github.io/2017/08/04/%E6%BE%9C%E6%BE%9C%E7%9A%84%E5%A4%A9%E4%B8%8A%E7%99%BD%E4%BA%91%E9%A3%98/"/>
    <id>http://tomatoyan.github.io/2017/08/04/澜澜的天上白云飘/</id>
    <published>2017-08-04T11:03:44.000Z</published>
    <updated>2017-12-10T13:35:51.591Z</updated>
    
    <content type="html"><![CDATA[<p>悄悄的告诉你这是一个随笔</p>
<pre><code>当神已无能为力，那便是魔渡众生。
</code></pre><p>&lt;!- end -&gt;</p>
<!-- 
     1
    别傻了，他不会回来的。
    “师兄说他当了最强的剑客便会回来了。”
    “这你也信，就他那修为，怎么会比得过荒嫖客呢~”

    荒嫖客何许人也？
    嫖这一字简练而生动，他剑术了得善攻人心，嫖心之术神佛敬畏。
    荒唐度日，嫖以维生，客以渡人。反而向他说的像个脱世之人，孰不知渡人之术乃是房中秘术，渡人则是以身渡人，以养剑气。

    而这位师兄只先前不过是一个落魄的书生，自以为书可以救人，可以化繁为简，阅己救人，或更是出人头地，娶得娇妻爱妾夜夜笙歌。乱世之中何来盛世之书，自得习武。
    书生好胜，自不愿武学差矣他人，剑以君子自居，自当学剑，立不世之功。
    何妨，剑气难养，故人以气养剑，以淫养气，以水养气，无所不养，无所不及。

    立不世之功，自当剑气浩荡，气煞旁荒。

      2
    “别打了，你剑气未足，我用脚都能。。。”
    “再来~”
    “真是浪费。”
    荒嫖客头也不回，向醉花楼走去。
    “师兄。。。”
    颓败之际唯有美酒与美女才能让人向往，不错，女人总是男人的解药。

    而你是伤我的剑。
-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;悄悄的告诉你这是一个随笔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当神已无能为力，那便是魔渡众生。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;lt;!- end -&amp;gt;&lt;/p&gt;
&lt;!-- 
     1
    别傻了，他不会回来的。
    “师兄说他当了最强的剑客便会回来了。”
  
    
    </summary>
    
    
      <category term="随笔" scheme="http://tomatoyan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>最近生活</title>
    <link href="http://tomatoyan.github.io/2017/08/04/%E6%9C%80%E8%BF%91%E7%94%9F%E6%B4%BB/"/>
    <id>http://tomatoyan.github.io/2017/08/04/最近生活/</id>
    <published>2017-08-04T10:22:48.000Z</published>
    <updated>2017-12-10T13:35:20.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近计划"><a href="#最近计划" class="headerlink" title="最近计划"></a>最近计划</h2><pre><code>其实朕只是个淫荡的狗皇帝，也不在乎什么狗命，也不懂什么喜欢朕的一生都在宫闱之内，头顶只有一方天地。
而天地都没有人心。

  是夜，群魔并举，王道崩倾。
    她太脏了。
        比朕的万里江山都脏。
                            ---朱炫
</code></pre><a id="more"></a>
<p>最近在想着未来，想着以后的生活，我该何去何从，未来又该是什么计划呢？</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><pre><code>1. 学习Spring系列，SpringBoot SpringMVC SpringCloud
2. 学习Java数据结构 算法 Linux
</code></pre><h2 id="具体目标"><a href="#具体目标" class="headerlink" title="具体目标"></a>具体目标</h2><pre><code>1. 每天要写计划，要学习多少，定量完成。
2. 编程题训练 每天 计算机网络 数据库 数据结构 等的练习
3. 每天40道笔试题，编程语言、计算机网络、数据库、操作系统各10道
</code></pre><p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最近计划&quot;&gt;&lt;a href=&quot;#最近计划&quot; class=&quot;headerlink&quot; title=&quot;最近计划&quot;&gt;&lt;/a&gt;最近计划&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;其实朕只是个淫荡的狗皇帝，也不在乎什么狗命，也不懂什么喜欢朕的一生都在宫闱之内，头顶只有一方天地。
而天地都没有人心。

  是夜，群魔并举，王道崩倾。
    她太脏了。
        比朕的万里江山都脏。
                            ---朱炫
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://tomatoyan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡的搭建</title>
    <link href="http://tomatoyan.github.io/2017/08/02/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://tomatoyan.github.io/2017/08/02/Nginx负载均衡的搭建/</id>
    <published>2017-08-02T02:56:18.000Z</published>
    <updated>2017-08-31T06:11:29.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx的简介"><a href="#Nginx的简介" class="headerlink" title="Nginx的简介"></a>Nginx的简介</h2><p>Nginx 是一个很强大的高性能Web和反向代理服务器。</p>
<h2 id="Nginx优点"><a href="#Nginx优点" class="headerlink" title="Nginx优点"></a>Nginx优点</h2><ol>
<li>作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率。在高连接并发的情况下，Nginx是Apache服务器不错的替代品，能够支持高达 50000 个并发连接数的响应。</li>
<li>Nginx 配置简洁, Apache 复杂 ，Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 . Nginx 静态处理性能比 Apache 高 3倍以上 ，Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端来使用 ,Apache 的组件比 Nginx 多. </li>
<li>最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；Nginx是异步的，多个连接（万级别）可以对应一个进程 .</li>
<li>Nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用Nginx作为反向代理抗住压力，apache作为后端处理动态请求。</li>
</ol>
<a id="more"></a>
<h2 id="Nginx-工作原理"><a href="#Nginx-工作原理" class="headerlink" title="Nginx 工作原理"></a>Nginx 工作原理</h2><p>Nginx会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。主进程以root用户身份运行，而worker、 cache loader和cache manager均应以非特权用户身份运行。</p>
<h2 id="Nginx的使用"><a href="#Nginx的使用" class="headerlink" title="Nginx的使用"></a>Nginx的使用</h2><p>目标：利用Nginx服务器反向代理对Tomcat进行负载均衡<br>需要的工具：Nginx、Tomcat<br>负载均衡：</p>
<h3 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><ol>
<li>首先下载 Nginx (<a href="http://nginx.org/en/download.html)在Linux上解压" target="_blank" rel="external">http://nginx.org/en/download.html)在Linux上解压</a> tar zxvf nginx-0.x.xx.tar.gz<br>进入解压目录：cd nginx-0.x.xx<br>./configure<br>make<br>sudo make install</li>
<li>Windows只需要解压即可完成安装</li>
</ol>
<h3 id="Nginx的启动"><a href="#Nginx的启动" class="headerlink" title="Nginx的启动"></a>Nginx的启动</h3><p>以上安装 nginx默认解压在 usr/local/nginx目录下。<br>所以启动的时候：usr/local/nginx/sbin/nginx -c  /usr/local/nginx/conf/nginx.conf<br>-c在这里是指定配置文件的路径，如果不指定，那么就是默认的<br>/usr/local/nginx/conf/nginx.conf<br>启动后我们可以通过 ps -ef | grep nginx 来查找Nginx的主进程号<br>master process代表住进程</p>
<p>Windows下直接点击解压包中的nginx.exe </p>
<h3 id="Nginx的停止"><a href="#Nginx的停止" class="headerlink" title="Nginx的停止"></a>Nginx的停止</h3><p>1) 从容停止Nginx<br>kill - QUIT <nginx 主进程号=""><br>或 kill - QUIT ‘/usr/local/nginx/logs/nginx.pid’<br>2) 快速停止Nginx<br>kill - TEAM <nginx 主进程号=""><br>kill - TEAM Nginx ‘/usr/local/nginx/logs/nginx.pid’<br>或<br>kill - INT <nginx 主进程号=""><br>kill - INT ‘/usr/local/nginx/logs/nginx.pid’<br>3) 强制停止所有Nginx进程<br>pkill -9 nginx<br>4) Nginx的平滑重启(因为是从容地重启，因此服务是不中断的)<br>kill - HUP <nginx 主进程号=""><br>kill - HUP ‘/usr/local/nginx/logs/nginx.pid’</nginx></nginx></nginx></nginx></p>
<p>Windows下退出直接在任务管理器停止进程即可</p>
<h2 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h2><p>由于Nginx做两个tomcat的反向代理和负载均衡，所以需要修改两个Tomcat的配置，只需要将两个Tomcat的端口号修改为指定端口号。<br>此处有三处需要修改端口号(修改文件为：apache-tomcat-XXX/conf/server.xml)：</p>
<pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;
&lt;Server port=&quot;18005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;
  &lt;GlobalNamingResources&gt;
    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;
              type=&quot;org.apache.catalina.UserDatabase&quot;
              description=&quot;User database that can be updated and saved&quot;
              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;
              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;
  &lt;/GlobalNamingResources&gt;
  &lt;Service name=&quot;Catalina&quot;&gt;
    &lt;Connector port=&quot;18080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; /&gt;
    &lt;Connector port=&quot;18009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;
       &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;resourceName=&quot;UserDatabase&quot;/&gt;
      &lt;/Realm&gt;
      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;
      &lt;/Host&gt;
    &lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre><p>一共三处 另一个tomcat改为 28005、28080、28009即可<br>配置Nginx<br>注：配置文件是nginx.conf文件</p>
<pre><code>worker_processes  2;#工作进程的个数，一般与计算机的cpu核数一致，或者是双倍
events {
    worker_connections  1024;#单个进程最大连接数（最大连接数=连接数*进程数）
}
http {
    include       mime.types; #文件扩展名与文件类型映射表
    default_type  application/octet-stream;#默认文件类型
    sendfile        on;#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    keepalive_timeout  65; #长连接超时时间，单位是秒
    gzip  on;#启用Gizp压缩
    #服务器的集群
    upstream  netitcast.com {  #服务器集群名字  此处是两个tomcat
        server    127.0.0.1:18080  weight=1;#服务器配置   weight是权重的意思，权重越大，分配的概率越大。
        server    127.0.0.1:28080  weight=2;
    }    
    #当前的Nginx的配置
    server {
        listen  80;#监听80端口，可以改成其他端口
        server_name  localhost;##############    当前服务的域名
    location / {
            proxy_pass http://netitcast.com;
            proxy_redirect default;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
</code></pre><h2 id="关闭日志操作-可选"><a href="#关闭日志操作-可选" class="headerlink" title="关闭日志操作(可选)"></a>关闭日志操作(可选)</h2><p>由于我们的服务需要在服务器上长久运行，日志文件的产生会导致服务器硬盘空间的不足，并且会对系统稳定性造成一定影响，所以我们可以选择关掉日志文件。</p>
<h3 id="Tomcat日志关闭"><a href="#Tomcat日志关闭" class="headerlink" title="Tomcat日志关闭"></a>Tomcat日志关闭</h3><p>将server.xml下的</p>
<pre><code>&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
           prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
           pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;
</code></pre><p>注释掉即可。</p>
<h3 id="Nginx日志关闭"><a href="#Nginx日志关闭" class="headerlink" title="Nginx日志关闭"></a>Nginx日志关闭</h3><pre><code>开发环境我默认不写日志，即不配置任何access_log
Nginx的http段中，设置access log：access_log off;
其他日志可以百度查找相关方法
</code></pre><p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nginx的简介&quot;&gt;&lt;a href=&quot;#Nginx的简介&quot; class=&quot;headerlink&quot; title=&quot;Nginx的简介&quot;&gt;&lt;/a&gt;Nginx的简介&lt;/h2&gt;&lt;p&gt;Nginx 是一个很强大的高性能Web和反向代理服务器。&lt;/p&gt;
&lt;h2 id=&quot;Nginx优点&quot;&gt;&lt;a href=&quot;#Nginx优点&quot; class=&quot;headerlink&quot; title=&quot;Nginx优点&quot;&gt;&lt;/a&gt;Nginx优点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率。在高连接并发的情况下，Nginx是Apache服务器不错的替代品，能够支持高达 50000 个并发连接数的响应。&lt;/li&gt;
&lt;li&gt;Nginx 配置简洁, Apache 复杂 ，Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 . Nginx 静态处理性能比 Apache 高 3倍以上 ，Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端来使用 ,Apache 的组件比 Nginx 多. &lt;/li&gt;
&lt;li&gt;最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；Nginx是异步的，多个连接（万级别）可以对应一个进程 .&lt;/li&gt;
&lt;li&gt;Nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用Nginx作为反向代理抗住压力，apache作为后端处理动态请求。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://tomatoyan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://tomatoyan.github.io/2017/08/01/hello-world/"/>
    <id>http://tomatoyan.github.io/2017/08/01/hello-world/</id>
    <published>2017-08-01T06:02:18.000Z</published>
    <updated>2017-08-31T06:10:22.384Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<a id="more"></a>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>&lt;!- end -&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://tomatoyan.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
